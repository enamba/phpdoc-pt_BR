<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.65 Maintainer: surfmax Status: ready -->
 <chapter id="security.index">
  <title>Segurança</title>

  <simpara>
   PHP é uma liguagem poderosa e interpretadora, se incluida num
    servidor web como um módulo ou executado em separado com um binário
   <acronym>CGI</acronym>, está apta a acessar arquivos, executar
   comandos e abrir conexões de rede no servidor.  Estas propriedades
   fazem qualquer coisa rodar em um servidor web inseguro.
   PHP é designado, especificadamente, para ser uma linguagem mais segura
   para escrever programas CGI do que Perl ou C, e com a seleção correta 
   da configuração de opções na compilação e na execução,
   e práticas de codificação apropriadas, ele pode te oferecer exatamente
   uma combinação de liberdade e segurança que você precisa.
  </simpara>
  <simpara>
   Como existem muitos caminhos diferentes de utilizar o PHP, há muitas
   opções de configuração controlando o seu comportamento. Uma grande seleção
   de opções garantem que você pode utilizar o PHP para uma infinidade
    de propósitos, mas isso também significa que há combinações destas opções
     e configurações do servidor que resultam em uma estrutura insegura.
   </simpara>
  <simpara>
  A flexibilidade da configuração do PHP é igualmente rival da
  flexibilidade do código. O PHP pode ser usado para construir aplicações 
  completas para servidores, com todo o poder de um usuário shell,
   ou ele pode ser usado para simplesmente server-side includes com baixo 
   risco em um ambiente firmemente controlado, e quão seguro ele é, depende 
   amplamente da capacidade do desenvolvedor PHP.
  </simpara>
  <simpara>
   Este capítulo começa com alguns avisos gerais de segurança,
   explica as diferentes combinações de opções de configuração e 
   as situações que elas podem ser seguramente utilizadas, e descreve
    diferentes considerações em codificação para diferentes níveis
     de segurança.
  </simpara>

  <sect1 id="security.general">
   <title>Considerações Gerais</title>
   <simpara>
    Um sistema completamente seguro é uma impossibilidade virtual, então
    uma aproximação geralmente utilizada na profissão de segurança é a de 
    balancear risco e usabilidade. Se cada variável submetida por um usuário
     requer dois formulários de validação biométrica (tal como um escaneamento
     da retina e impressão digital), você teria um nível extremamente alto
     de responsabilidade. Isto também levaria meia hora para preencher um
    formulário complexo corretamente, que tenderia a encourajar usuários a
    encontrar maneiras de contornar a segurança.
   </simpara>
   <simpara>
    A melhor segurança é geralmente discreta o bastante para satisfazer
    as exigências sem o usuário ser prevenido da insegurança na execução
     de seu trabalho, ou sobrecarregar o autor do código com excessiva
      complexidade. Sem dúvida, alguns ataques à segurança são meramente
      formas de se aproveitar desta segurança exacerbada, que tende a 
      corroer-se com o tempo.
    </simpara>
   <simpara>
    Uma frase digna de lembrança: Um sistema é tão bom quanto o mais fraco 
    elo de uma corrente. Se todas as transações são logadas pesadamente 
    baseadas no tempo, localização, tipo de transação, etc. mas o usuário
     é verificado  através de um simples cookie, a validação da conexão
      com os usuários para o log da transação é severamente enfraquecido.
   </simpara>
   <simpara>
    Quando testando, lembre-se que você não está apto a testar todas as
    possibilidades, mesmo para a mais simples das páginas. A entrada que
    você pode esperar será completamente sem relação com a entrada dada por
    um trabalhador decepcionado, um "cracker"(pessoa com habilidades de 
    quebrar códigos de acesso a programas e etc) com meses do tempo em suas 
    mãos, ou um gato passeando pelo teclado. Isto porque, é melhor observar
    o código por uma perspectiva lógica, para dicernir onde dados inesperados
    podem ser introduzidos, e então segue como eles são modificados, reduzidos,
    ou amplificados.
   </simpara>
   <simpara>
    A internet é cheia de pessoas tentando fazer um nome para elas,
     quebrando o seu código, detonar o seu site, colocar conteúdo impróprio,
      e de outra forma fazer o seu dia ficar interessante. Isso não importa 
    se você tem um pequeno ou um grande site, você é um alvo por está
    simplesmente online, por ter um servidor que pode está conectado. 
    Muitos programas de "Cracking" (programas utilizados pelos crackers)
     não enxergam pelo tamanho, eles simplesmente arrastam em massa
      blocos de IP procurando por vítimas. Tente não ser uma delas.
   </simpara>
  </sect1>

  <sect1 id="security.cgi-bin">
   <title>Instalado como binário CGI</title>

   <sect2 id="security.cgi-bin.attacks">
    <title>Possíveis ataques</title>
    <simpara>
     Usando o PHP como um binário <acronym>CGI</acronym> é uma opção
     para configuração que por alguma razão não deseja integrar o PHP
     como módulo dentro de um programa de servidor (como o Apache), ou 
     utilizará o PHP com CGI de diferentes tipos de roupagem para criar
     ambientes chroot e setuid seguros para scripts. Este setup geralmente
     envolve instalação do executável do PHP binário para o diretório
     cgi-bin do servidor web. CERT (Equipe de suporte a emergência de 
     computadores) de consulta <ulink url="&url.cert;">CA-96.11</ulink>
     é contra instalação de qualquer interpretador dentro do cgi-bin. Mesmo
     se o binário PHP pode ser usado como um interpretador em 
     standalone (sozinho), o PHP é designado para prevenir os ataques
     que esta configuração é capaz:
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       Acessando sistema de arquivos: <filename
       role="url">http://my.host/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
       A informação de query em uma url depois da interrogação (?)  é 
       como argumentos de linha de comando para o interpretador
       pela interface CGI. Normalmente interpretadores abrem e executam
       o arquivo especificado como o primeiro argumento na linha de 
       comando.
      </simpara>
      <simpara>
       Quando invocado como um binário, o PHP recusa-se a interpretar
       os argumentos de linha de comando.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Acessando qualquer documento do servidor web: <filename
       role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
       A informação do caminho na parte da url após o nome do binário PHP,
       <filename role="uri">/secret/doc.html</filename> é convencionalmente
       usado para especificar o nome do arquivo para ser aberto e
        interpretado pelo programa <acronym>CGI</acronym>.
       Normalmente algumas diretivas de configuração de servidores
       (Apache: Action) são usadas para redirecionar pedidos para
       documentos como
       <filename
       role="url">http://my.host/secret/script.php</filename> para o 
       interpretador de PHP.  Com este setup, o servidor primeiro checa
       as permissões de acesso aothe access permissions para o diretório
       <filename
       role="uri">/secret</filename>, e depois que cria o pedido 
       redirecionado
       <filename
       role="url">http://my.host/cgi-bin/php/secret/script.php</filename>.
       Desafortunadamente, se o pedido é originalmente feito desta forma,
       não são feitas checagens de acesso pelo servidor para o arquivo
       <filename
       role="uri">/secret/script.php</filename>, mas apenas para o arquivo
       <filename role="uri">/cgi-bin/php</filename>.  Desta forma
       qualquer usuário está apto a acessar <filename
       role="uri">/cgi-bin/php</filename> está apto a acessar
       qualquer documento protegido dentro do servidor.
      </simpara>
      <simpara>
       No PHP, opção de configuração de compile-time (tempo de 
       compilação) 
       <link linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
       e diretivas de configuração de tempo de execução <link
       linkend="ini.doc-root">doc_root</link> e <link
       linkend="ini.user-dir">user_dir</link> podem ser usadas para
       prevenir este ataque, se a árvore de documentos do servidor tem
       quaisquer diretórios com restrições de acesso. Veja abaixo
       para uma explicação completa de diferentes combinações.
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="security.cgi-bin.default">
    <title>Caso 1: apenas arquivos públicos no servidor</title>

    <simpara>
    Se seu servidor não tem qualquer conteúdo que não seja restrito
    por senha ou baseado em ip para controlar o acesso, não há necessidade
    ára estas opções de configuração. Se seu servidor não permite que
    você faça redirecionamentos, ou o servidor não uma forma de comunicar
     o binário PHP que a solicitação é um pedido de redirecionamento seguro,
     você pode especificar a opção <link
     linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
     para o script de configuração. Você ainda tem que ter certeza que 
     seu script PHP faça com que não dependa de uma ou outra forma de chamar
     de ser chamado, nenhum dos dois de modo direto <filename
     role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
     nem por redireção <filename
     role="php">http://my.host/dir/script.php</filename>.
    </simpara>
    <simpara>
     Redireção pode ser configurada no Apache usando AddHandler (adicionar
      manipulador) e diretivas de ação (veja abaixo).
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.force-redirect">
    <title>Caso 2: usando --enable-force-cgi-redirect</title>
    <simpara>
     Esta opção de compilação evita de qualquer um chamar o PHP diretamente
     com uma url como <filename
     role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename>.
     Ao contrário, o php apenas analisa neste modo se ele atravessou uma regra de
     redirecionamento de um webserver.
    </simpara>
    <simpara>
     Normalmente esta redireção na configuração do Apache é feita com as
     seguintes diretivas: 
    </simpara>
    <programlisting role="apache-conf">
<![CDATA[
Action php-script /cgi-bin/php
AddHandler php-script .php
]]>
    </programlisting>
    <simpara>
     Esta opção foi testada apenas com o servidor Apache, e conta com
     o Apache para ajustar a variável de ambiente CGI non-standard (não-padrão)
     <envar>REDIRECT_STATUS</envar> em pedidos redirecionados.  Se seu servidor
     não suporta nenhuma forma de descobrir se o pedido é direcionado 
     ou redirecionado, você não pode usar esta opção e você deve usar umas
     das outras formas de executar a versão CGI documentada aqui.
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.doc-root">
    <title>Caso 3: definindo doc_root ou user_dir</title>
    <simpara>
     Para incluit conteúdo ativo, como scripts e executáveis, nos
     diretórios de documentos do servidor é considerada, às vezes uma
     prática insegura. Se, por causa de alguns erros de configuração, os
     scripts não são executados mas exibidos como documentod html normais, 
     isto pode resultar em exibição de propriedades intelectuais e informações
     de segurança como senhas. Então alguns administradores de sistema
     irão preferir configurar outra estrutura de diretório para scripts que
     são acessíveis apenas por CGI PHP, então sempre interpretado e não
     é exibido como da outra forma.
    </simpara>
    <simpara>
     Também se o método que verifica se o pedido não é 
     redirecionado, como descrito na seção anterior, não está
     disponível, é necessário definir um doc_root de script que
     é diferente de um document root da web.
    </simpara>
    <simpara>
     você pode definir o document root de script pela diretiva de
     configuração <link linkend="ini.doc-root">doc_root</link> no
     <link linkend="configuration.file">arquivo de configuração</link>, ou
     você pode definir a variável de ambiente
     <envar>PHP_DOCUMENT_ROOT</envar>.  Se ela estiver definida, a versão
     CGI do PHP sempre construirá o nome do arquivo para abrir com este
     <parameter>doc_root</parameter> e a informação do caminho no pedido,
     então você pode que nenhum script será executado de fora deste 
     diretório (exceto para <parameter>user_dir</parameter>
     abaixo).
    </simpara>
    <simpara>
     Uma outra opção útil é <link
     linkend="ini.user-dir">user_dir</link>.  Quando user_dir não está
      definida, apenas uma coisa que tem o controle do nome de arquivo 
      aberto é <parameter>doc_root</parameter>.  Abrindo uma url 
      como <filename role="url">http://my.host/~user/doc.php</filename> 
      não resulta em abertura de um arquivo de dentro do diretório home
      de usuários, mas um arquivo 
      chamado <filename role="uri">~user/doc.php</filename> dentro de
     doc_root (sim, um nome de diretório começando com um til
     [<literal>~</literal>]).
    </simpara>
    <simpara>
     Se user_dir está definido para, exemplo <filename
     role="dir">public_php</filename>, um pedido como <filename
     role="url">http://my.host/~user/doc.php</filename> abrirá um
     arquivo chamado <filename>doc.php</filename> de dentro do diretório
     nomeado <filename role="dir">public_php</filename> de dentro do
      diretório do usuário.  Se o home do usuário é <filename
     role="dir">/home/user</filename>, o arquivo executado é
     <filename>/home/user/public_php/doc.php</filename>.
    </simpara>
    <simpara>
     A expansão de <parameter>user_dir</parameter> acontece apesar da
      configuração de <parameter>doc_root</parameter>, então você pode
      controlar o acesso de document root e diretório de usuário (user)
     separadamente.
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.shell">
    <title>Caso 4: Analisador de PHP de fora da árvore web</title>
    <para>
     Uma opção segura é colocar o analisador de PHP binário
     em algum lugar de fora da árvore de arquivos da web. Em <filename
     role="dir">/usr/local/bin</filename>, por exemplo. O único porém
     desta opção é que você agora terá que colocar uma linha similar a:
      <informalexample>
      <programlisting>
<![CDATA[
#!/usr/local/bin/php
]]>
      </programlisting>
     </informalexample>
     como a primeira linha de qualquer arquivo contendo tags de PHP. Você
     também precisará marcar o arquivo executável. Que é tratá-lo exatamente
     como você trataria um outro script CGI escrito em PERL ou SH ou qualquer
     outra linguagem comum que utiliza o mecanismo
     <literal>#!</literal> shell-escape para se auto-executar.
    </para>
    <para>
     Obter o PHP para manipular a informação de <envar>PATH_INFO</envar> e
     <envar>PATH_TRANSLATED</envar> corretamente com este setup,
     o analisador de PHP seria compilado com a opção de configuração <link
     linkend="install.configure.enable-discard-path">--enable-discard-path</link>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="security.apache">
   <title>Instalando como um módulo do Apache</title>
   <simpara>
    Quando o PHP é usado como um módulo do Apache ele herda as permissões
    de usuários do Apache (tipicamente aquelas do usuário "nobody" (ninguém)).
    Isto tem impactos severos na segurança e autorização. Por exemplo, se você 
    está usando o PHP para acessar um banco de dados, a menos que o banco de
    dados tenha nele controle de acesso, você terá que fazer o acesso ao banco
    de dados para o usuário "nobody" (ninguém). Isto significa que um script
    malicioso poderia acessar e modificar o banco de dados, sem login e senha
    . É inteiramente possível que "web spider" (ferramenta de programas de busca
    que atualizam a sua base de dados através de navegação na rede e na procura de 
    páginas novas) poderia esbarrar no banco de dados da página do adminstrador.
    e eliminar tudo de seus bancos de dados. Você pode se proteger contra isto
    com a autorização do Apache, ou você pode desenvolver seu próprio modelo
    de acesso usando LDAP, arquivos &htacess;, etc. e incluir esse código como
    parte de seus scripts PHP.
   </simpara>
   <simpara>
    Muitas vezes, logo que a segurança está estabelecida para o ponto
    onde o usuário PHP (neste caso, o usuário do Apache) tem pouquíssimo
     risco ligado, é revelado que o PHP está agora prevenido de
     escrever quaisquer arquivos para diretórios de usuários. Ou talvez
     ele seja impedido de acessar ou mudar banco de dados. Issi tem sido
     igualmente assegurado da escrita de arquivos bons e maus, ou entradas
      de transações a banco de dados boas ou más.
   </simpara>
   <simpara>
    Um erro de segurança comum feito desta forma é permitir acesso ao
    root do apache, ou expandir as habilidades do apache em algum outro
    caminho.
   </simpara>
   <simpara>
    Aumentar as permissões do usuário do apache para root é extremamente 
    perigoso e pode comprometer todo o seu sistema, então utilizar o 
    sudo(permitindo a um usuário realizar alguma tarefa como root) ou o 
    chroot(mudando o diretório raíz do sistema) ou  qualquer outra forma 
    de executar como root não seria considerado por pessoas que não são 
    profissionais em segurança.
   </simpara>
   <simpara>
    Há algumas soluções mais simples. Ao usar
    <link linkend="ini.open-basedir">open_basedir</link> você pode controlar
     e restringir quais os diretórios são permitidos para ser usado pelo PHP.
     Você pode também definir áreas de somente-apache, para restringir para 
     não-usuário toda atividade baseada em web, ou não-sistema, para os arquivos.
   </simpara>
  </sect1>

  <sect1 id="security.filesystem">
   <title>Segurança de sistema de arquivos</title>
   <simpara>
    O PHP é assunto para a segurança construída na maioria dos sistemas de 
    servidor, com respeito a permissões em um arquivo e em bases de
     diretórios. Isto permite que você controle quais arquivos no sistema
     de arquivos podem ser lidos. Cuidados deveriam ser tomados com arquivos
     que são liberados para leitura para a assegurar que eles estão protegidos
     para leitura para todos os usuários que tem acesso a esse sistema de 
     arquivos.
   </simpara>
   <simpara>
    Visto que o PHP foi desenvolvido para permitir acesso por nível
    de usuário ao sistema de arquivos, é inteiramente possível escrever
    um script PHP que permitirá a você ler sistema de arquivos tais como
    /etc/password, modificar suas conexões de ethernet, enviar trabalhos
    de impressora em massa para fora, etc. Isto tem algumas implicações
    óbvias, no que você precisa garantir que estes arquivos que você lê
    e escreve estão nos locais apropriados.
     
   </simpara>
   <simpara>
    Considere o seguinte script, onde um usuário indica que eles tem 
    como deletar um arquivo em seus diretórios home. Assume-se uma situação
    onde a interface web do PHP é usada regularmente para gerenciamento de
    arquivos, então o usuário do Apache está liberado para apagar arquivos
    nos diretórios home.
   </simpara>
   <para>
    <example>
     <title>Checagem pobre de variável leva a....</title>
     <programlisting role="php">
<![CDATA[
<?php
// remove um arquivo de diretório home do usuário
$usuario = $_POST['user_submitted_name'];
$homedir = "/home/$usuario";
$file_to_delete = "$userfile";
unlink ("$homedir/$userfile");
echo "$file_to_delete foi deletado!";
?>
]]>
     </programlisting>
    </example>
   Visto que o username é postável de um formulário de usuário,
    eles podem submeter um nome de usuário e arquivar pertencendo
     a outra pessoa, e deletar arquivos. Neste caso, você tem que
     utilizar outra forma de autenticação. Considere o que aconteceria 
     se as variáveis submetidas fossem "../etc/" e "passwd". O código
     então leria efetivamente:
    <example>
     <title>... Um ataque de sistema de arquivos</title>
     <programlisting role="php">
<![CDATA[
<?php
// remove um arquivo de algum lugar no disco que o usuário
// do PHP tem acesso. Se o PHP possui acesso ao root:
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd foi deletado!";
?>
]]>
     </programlisting>
    </example>
    Há duas medidas importantes que você tomaria para prevenir estas coisas.
    
    <itemizedlist>
     <listitem>
      <simpara>
       Apenas deixar permissões limitadas ao usuário PHP binário.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Checar todas as variáveis que são submetidas.
      </simpara>
     </listitem>
    </itemizedlist>
    Aqui está um script melhorado:
    <example>
     <title>Checagem de nome de arquivo mais seguro</title>
     <programlisting role="php">
<![CDATA[
<?php
// remove um arquivo do hd que o PHP usa para acessá-lo

$username = $_SERVER['REMOTE_USER']; // usando um mecanismo de autenticação

$homedir = "/home/$username";

$file_to_delete = basename("$userfile"); // Retira o caminho
unlink ($homedir/$file_to_delete);

$fp = fopen("/home/logging/filedelete.log","+a"); //Logar a deleção
$logstring = "$username $homedir $file_to_delete";
fputs ($fp, $logstring);
fclose($fp);

echo "O $file_to_delete foi deletado!";
?>
]]>
     </programlisting>
    </example>
    However, even this is not without it's flaws. Se seu sistema de autenticação
     permite aos usuários criar seus próprios logins, e um usuário
     escolhe o login "../etc/", o sistema é exposto de novo. Por esta
     razão, você pode preferir escrever uma checagem mais detalhada:
     
    <example>
     <title>Verificação de nome de arquivo mais segura</title>
     <programlisting role="php">
<![CDATA[
<?php
$username = $_SERVER['REMOTE_USER']; // Usando um mecanismo de atenticação
$homedir = "/home/$username";

if (!ereg('^[^./][^/]*$', $userfile))
     die('nome de arquivo maldoso'); //interromper, não processa

if (!ereg('^[^./][^/]*$', $username))
     die('nome de usuario maldoso'); //interromper, não processa
//etc...
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Dependendo de seu sistema operacional, há uma ampla variedade de arquivos
    que você estaria preocupado, incluindo entradas de dispositivos  (/dev/
    ou COM1), arquivos de configuração (arquivos /etc/  e os arquivos .ini),
    áreas de armazenamento de arquivos conhecidas (/home/, Meus Documentos), 
    etc. Por este motivo, é normalmente mais fácil criar um policiamento
     onde você proibe tudo exceto para o que você permitir explicitamente.
   </para>
  </sect1>

  <sect1 id="security.database">
   <title>Segurança de Bando de Dados</title>

   <simpara>
    Atualmente, bancos de dados são componentes primordiais de qualquer 
    aplicação web, por permitir aos websites fornecer variedades de conteúdos
    dinâmicos. Visto que informações muito sensíveis ou secretas podem ser 
    guardadas em bancos, você considera fortemente a proteção de
    seus bancos de dados.
   </simpara>
   <simpara>
    Para resgatar ou guardar qualquer informação você conecta ao banco de dados,
     envia uma requisição legitimada, pega o resultado, e fecha a conexão.
     Atualmente, a linguagem de requisição mais usada nesta interação é a 
     Linguagem de Requisição Estruturada Structured Query Language (SQL).
     Veja como um agressor pode  <link
    linkend="security.database.sql-injection">se engajar com uma requisição
     SQL</link>.
   </simpara>
   <simpara>
    Como você pode pensar, o PHP não pode proteger seu banco de dados por si só.
    As seções seguintes fazem uma introdução nos muitos fundamentos de como
    acessar e manipular banco de dados com scripts PHP. 
   </simpara>
   <simpara>
    Mantenha em sua mente uma regra simples: defesa em completo. 
    Em lugares que você toma mais ações para aumentar a proteção de seu
    banco tem menos probabilidade de que uma um invasor tenha sucesso, e
    exponha ou faça mau uso de qualquer informação secreta que esteja guardada.
    Esquema de banco de dados bem desenhado e as aplicações comerciais tratados com  
    seus maiores receios.
   </simpara>

   <sect2 id="security.database.design">
    <title>Estruturando Banco de dados</title>
     <simpara>
      O primeiro passo é sempre criar o banco de dados, a menos  que você queira
      utilizar um já existente, terceirizado. Quando um banco de dados é criado, ele
      é designado para um proprietário, que executa a instrução de criação. Normalmente,
      apenas o proprietário (ou um superusuário) pode fazer qualquer coisa com os objetos
      no banco de dados, e para permitir que outros usuários o utilizem, privilégios 
      devem ser concedidos.
     </simpara>
     <simpara>
      Aplicações nunca conectariam ao banco de dados como sendo o proprietário
      ou um superusuário, porque estes usuários podem executar qualquer instrução
      à sua vontade, por exemplo, modificar o esquema (apagando tabelas) ou deletando
      todo o conteúdo.
     </simpara>
     <simpara>
      Você pode criar diferentes usuários de banco de dados para cada aspecto 
      de sua aplicação com muitos direitos limitados aos objetos do banco. A 
      maioria dos privilégios requeridos seria concedido apenas, e evitaria que o 
      mesmo usuário pudesse interagir com o banco de dados em diferentes situações.
      Isto significa que se os invasores conseguem acessar seu banco de dados usando uma
      destas credenciais de sua aplicação, eles podem apenas efetuar tantas mudanças quanto a sua aplicação
      puder.
     </simpara>
     <simpara>
      Você é encourajado a não implementar toda a lógica de negócios na aplicação
      web (i.e em seu script), ao invés disso faça-o em um esquema de banco de dados
      usando views, triggers ou regras.  Se o sistema evolui, novas portas serão
      planejadas para abrir o banco de dados, e você tem que re-implementar a lógica
      em cada cliente de banco de dados em separado. Acima ou abaixo, triggers podem
      ser usados para manipular campos automaticamente e com tranparência, que 
      frequentemente oferece muita ajuda quando se está tirando os bugs de sua aplicação
      ou traçando transações anteriores.
     </simpara>
   </sect2>

   <sect2 id="security.database.connection">
    <title>Conectando ao Banco de Dados</title>
    <simpara>
     Você pode querer estabelecer conexões com SSL para encriptar comunicações
     cliente/servidor para aumentar a segurança, ou você pode usar ssh para
     encriptar a conexão de rede entre clientes e o servidor do banco de dados.
     Se você quer estabelecer conexões com SSL para encriptar comunicações 
     cliente/servidor para aumentar a segurança, ou você pode utilizar SSH para
     encriptar a conexão  da rede entre clientes e servidor do banco de dados.
     Se uma das duas opções é usada, então monitorar seu tráfego e obter informação
     sobre seu banco de dados será difícil para um suposto invasor.
    </simpara>
    <!--simpara>
     Se seu banco de dados tem suporte a SSL, considere usando <link
     linkend="ref.openssl">OpenSSL functions</link> na comunicação entre
     PHP e o banco de dados via SSL.
    </simpara-->
   </sect2>

   <sect2 id="security.database.storage">
    <title>Modelo de Armazenamento Encripitado</title>
    <simpara>
     SSL/SSH protege dados viajando do cliente para o servidos, SSL/SSH não
     protege os dados persistentes guardados no banco. SSL é um protocolo      
     on-the-wire.
    </simpara>
    <simpara>
     Uma vez que um invasor ganha acesso ao seu banco de dados diretamente (passando
     pelo servidor web), os dados sensíveis podem ser expostos ou receber um mal uso,
     a menos que a informação esteja protegida pelo próprio banco. Encriptar os dados
     é uma boa maneira de aliviar esta ameaça, mas pouquíssimos bancos de dados oferecem
     este tipo de encriptação de dados.
    </simpara>
    <simpara>
     A maneira mais fácil de contornar este problema é primeiro criar o seu proprio
     pacote de encriptação, e então usá-lo de dentro de seus scripts PHP. O PHP
     pode auxiliar você nisto com suas várias extensões, tais como <link
     linkend="ref.mcrypt">Mcrypt</link> e <link
     linkend="ref.mhash">Mhash</link>, simulando uma ampla variedade de algorítimos de
     encriptação. O script encripta os dados antes de inserí-los em um banco de dados,
     e desencripta-os ao devolvê-los. Veja as referências para mais exemplos de como a 
     encriptação trabalha.
    </simpara>
    <simpara>
     No caso de dados verdadeiramente escondidos, se sua representação original
     não é necessária (i.e. não ser mostrada), embaralhamento (hashing) pode 
     também ser levado em consideração. O exemplo bem conhecido para 
     embaralhamento é guardando o a senha com o hash MD5 em um banco de dados,
      ao invés da própria senha. Veja também <function>crypt</function> e 
     <function>md5</function>.
    </simpara>
    <example>
     <title>Usando campo de senha embaralhado (hashed)</title>
     <programlisting role="php">
<![CDATA[
// guardando senha embaralhada
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

// pesquisando se o usuário submeteu a senha correta
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

if (pg_numrows($result) > 0) {
    echo "Bem vindo, $username!";
}
else {
    echo "Falha na autenticação para $username.";
}
]]>
     </programlisting>
    </example>
   </sect2>

   <sect2 id="security.database.sql-injection">
    <title>Injeção de SQL (SQL Injection)</title>
    <simpara>
     Muitos programadores de web não estão cientes de como solicitações SQL devem 
     ser feitas com cuidado, e assumem que uma solicitação SQL é um comando confiável.
     Isso significa que solicitações SQL estão aptas a driblar controles de acesso,
     através de passagens de sistemas de autenticação padrão e vericações de autorização, 
     e alguma vezes  solicitações SQL podem até permitir acesso a comandos do sistema 
     operacional do host.
    </simpara>
    <simpara>
     Injeção de comandos SQL direto é uma técnica onde um agressor cria ou altera
     comandos SQL existentes para expor dados escondidos, ou cancelar dados valiosos, 
     ou até executar comandos de sistema operacional no host do banco de dados. Isto
     é efetuado por uma aplicação que pega entradas de usuários e combinando-a com 
     parâmetros estáticos para construir uma solicitação SQL. Os seguintes exemplos 
     são baseados em histórias verdadeiras, infelizmente.     
    </simpara>
    <para>
     A falta de uma validação na entrada, leva a uma conexão ao banco de dados
     como superusuário ou aquele que pode criar usuários, o agressor pode criar
     um superusuário em seu banco de dados.
     <example>
      <title>
      Dividindo o conjunto de resultados em páginas ... e fazendo superusuários
      (PostgreSQL e MySQL)
      </title>
      <programlisting role="php">
<![CDATA[
$offset = argv[0]; // tome cuidado, sem validação de entrada!
$query  = "SELECT id, nome FROM produtos ORDER BY nome LIMIT 20 OFFSET $offset;";
// com PostgreSQL 
$resultado = pg_exec($conn, $query);
// com MySQL
$resultado = mysql_query($query);
]]>
      </programlisting>
     </example>
      Usuários comuns clicam nos links 'próximo', 'anterior' onde o 
      <varname>$offset</varname> está codificada na URL. O script espera que
      a entrada de <varname>$offset</varname> é um número decimal. No entando,
      o que acontece se alguém tenta quebrar anexando uma forma de <function>urlencode</function>
      seguindo para a URL.
      <informalexample>
       <programlisting>
<![CDATA[
// no caso do PostgreSQL
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// no caso do MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;
]]>
       </programlisting>
      </informalexample>
      Se isso aconteceu, então o script concederia um acesso como superusuário para ele.
      Note que <literal>0;</literal> é para fornecer um offset válido para a solicitação
      original e terminá-la.
    </para>
    <note>
     <para>
      Está é uma técnica comum para forçar o interpretador SQL a ignorar o resto da 
      solicitação escrita pelo desenvolvedor com <literal>--</literal> que é o sinal
      de comentário em SQL.
     </para>
    </note>
    <para>
     Uma forma acessível de ganhar senhas é driblar suas páginas de resultados de pesquisa.
     A única coisa que o invasor precisa fazer é ver se há quaisquer variáveis submetidas usadas na 
     instrução SQL que não é manipulada adequadamente. Estes filtros podem ser definidos,
     geramente em um formulário precedente para customizar instruções <literal>WHERE, ORDER BY, 
     LIMIT</literal> e <literal>OFFSET</literal> cláusulas em <literal>SELECT</literal>. Se seu 
     banco de dados suporta o construtor <literal>UNION</literal>, o agressor pode tentar anexar
     uma solicitação inteira para o original para listar senhas de uma tabela arbitrária. Usar
     campos de senhas criptografados é altamente recomendado. 
      <example>
      <title>
       Listando artigos ... e algumas senhas (qualquer servidor de banco de dados)
      </title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);
]]>
      </programlisting>
     </example>
     A parte estática da solicitação (query)  pode ser combinada com uma outra instrução 
      <literal>SELECT</literal> que revela todos as senhas:
     <informalexample>
      <programlisting>
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
     Se esta solicitação (agindo com o <literal>'</literal> e
     <literal>--</literal>) foi atribuida para uma das variáveis usadas na
     <varname>$query</varname>, a solicitação perversa é despertada.
    </para>
    <para>
     SQL UPDATE's tambémes suscepatíveis a ataques. Estas solicitações 
     estão também ameaçadas em ser cortadas e anexadas a elas uma nova solicitação inteira.
     Mas o agressor pode brincar com a cláusula <literal>SET</literal>. Neste caso alguma
     informação de esquema deve ser tomado para manipuar a solicitação com sucesso. Isto pode
     ser adquirido pela examinação dos nomes das variáveis do formulário, ou apenas pela força 
     bruta. Não há, então, muitas convenções de nomeação para campos guardando senhas e logins.
     <example>
     <title>
      Recriando uma senha ... para obter mais privilégios (qualquer banco de dados)
     </title>
      <programlisting role="php">
<![CDATA[
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
]]>
      </programlisting>
     </example>
     Mas um usuário malicioso submete o valor
     <literal>' or uid like'%admin%'; --</literal> para <varname>$uid</varname> afim de
     mudar a senha do administrador, ou simplesmente definir <varname>$pwd</varname> para
     <literal>"'hehehe', admin='yes', trusted=100 "</literal> (with a trailing
     space) para obter mais privilégios. Então, a solicitação será deformada:
     <informalexample>
      <programlisting role="php">
<![CDATA[
// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Um exemplo terrível de como comandos de sistema operacional podem ser acessados
     em alguns hosts de banco de dados.
      
     <example>
     <title>Atacando o sistema operacional de hosts de banco de dados (MSSQL Server)</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     Se o atacante submete o valor
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     para <varname>$prod</varname>, então a <varname>$query</varname> será:
     <informalexample>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);
]]>
      </programlisting>
     </informalexample>
     MSSQL Server executa o lote de instruções SQL que  inclui um comando para
     adicionar um novo usuário para a conta local do banco de dados. Se esta
     aplicação estava rodando como <literal>sa</literal> e o serviço de MSSQLSERVER
     está rodando com privilégios suficientes, o agressor agora teria uma conta
      para acessar está máquina.
    </para>
    <note>
     <para>
      Alguns dos exemplos acima diz respeito a um banco de dados específico. Isto
      não significa que um ataque similar é impossível contra outros produtos.
      Seu banco de dados pode estar similarmente vulnerável de outra forma.
     </para>
    </note>

    <sect3 id="security.database.avoiding">
     <title>Técnicas de Prevenção</title>
     <simpara>
      Você pode alegar que o agressor deve possuir uma peça de informação sobre o
      esquema do banco de dados na maioria dos exemplos. Você está certo, mas você
       nunca sabe quando e como ele pode se relacionar, e se isso acontece, seu 
       banco de dados pode estar exposto. Se você está usando manipulador de 
       banco de dados open source (código aberto), ou um públicamente disponível, 
       que pode fazer parte de um sistema de gerenciamento de conteúdo ou forum,
       o intruso pode fácilmente produzir uma cópia de uma peça de seu código. Isso
        pode ser, também, um risco na segurança se ele está pobremente desenvolvido.
     </simpara>
     <simpara>
      Estes ataques podem ser baseados na exploração de códigos que, ao serem
      escritos não consideraram a segurança. Nunca confie em nenhum tipo de entrada,
       especialmente as que vem do lado do cliente, mesmo que ela venha de uma
       caixa de seleção, de um campo hidden ou um cookie. O primeiro exemplo mostra
       que um solicitação (query) inocente pode causar disastres.
     </simpara>

     <itemizedlist>
      <listitem>
       <simpara>
        Nunca conecte ao banco de dados como superusuário ou como proprietário.
        Utilize sempre usuários, ajustados com privilégios bastante limitados.
        </simpara>
      </listitem>
      <listitem>
       <simpara>
        Verifique se uma dada entrada tem o tipo de dado esperado. O PHP tem
        uma vasta área de funções de validação de formulários, a mais simples
         destas é <link linkend="ref.variables">Funções de Variáveis</link> e
        in <link linkend="ref.ctype">Character Type Functions</link>
        (ex <function>is_numeric</function>, <function>ctype_digit</function>
        respectivamente) e mais adiante temos suporte a
         <link linkend="ref.pcre">Expressões Regulares Perl compatible</link>.
          </simpara>
      </listitem>
      <listitem>
       <para>
        Se a aplicação espera por uma entrada numérica, considere a verificação
        dos dados com <function>is_numeric</function>, ou mudando o seu tipo usandos
         <function>settype</function>, ou utilize sua representação numérica por
         <function>sprintf</function>.
        <example>
         <title>Uma forma mais segura de compor uma solicitação para paginar</title>
         <programlisting role="php">
<![CDATA[
settype($offset, 'integer');
$query = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";

// por favor note que %d no formato de string, usando %s seria insignificante
$query = sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",
                 $offset);
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
        Ponha entre aspas cada entrada não numérica do usuário que é passada para
        o banco de dados com <function>addslashes</function> ou
         <function>addcslashes</function>.
        Veja <link linkend="security.database.storage">O primeiro exemplo</link>.
        Conforme mostrado no exemplo, por aspas dentro da parte estática da solicitação
        não é o bastante, e pode ser facilmente crackeado.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Não imprima nenhuma informação específica do banco de dados, especialmente sobre
        o esquema, através de todos os recursos. Veja Também
        Do not print out any database specific information, especially
        about the schema, by fair means or foul. See also <link
        linkend="security.errors">Reportando Erro</link> e <link
        linkend="ref.errorfunc">Manipulação de Erro e Funções de Logging (registrar atividades 
        ocorridas no computador)</link>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Você pode utilizar procedimentos guardados e cursores definidos previamente para 
        resumir acessos a dados assim que os usuários não acessem as tabelas ou views diretamente,
        mas esta solução tem outros impactos. 
        </simpara>
      </listitem>
     </itemizedlist>
     <simpara>
     Além destes, você se beneficia de solicitações de logging, ou dentro de seu
     script ou pelo próprio banco de dados, se ele suportar logging. Obviamente, o logging está
     indisponível para impedir qualquer tentativa prejudicial, mas ele pode ser útil
     para rastrear qual aplicação está sendo driblada. O log não é util por si só, mas
     sim as informações que ele contém. Quanto mais detalhes melhor.
     </simpara>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="security.errors">
   <title>Relatório de Erro</title>
   <para>
    Com a segurança do PHP, há dois lados para relatório de erro. Um é 
    benéfico para aumentar a segurança, o outro é prejudicial.
   </para>
   <para>
   Uma tática de ataque padrão envolve traçar o perfil de um sistema inserindo
   dados impróprios, e verificando os tipos, e contexto dos erros que são exibidas.
   Isto permite ao cracker examinar as informações sobre o servidor, para determinar
   possíveis fraquezas. Por exemplo, se um hacker colheu informações sobre uma
   página anterior a uma submissão de formulário, eles podem tentar cancelar variáveis,
   ou modificá-las:
    <example>
     <title>Atacando Variáveis com uma páginca HTML personalizada</title>
     <programlisting role="php">
<![CDATA[
<form method="POST" action="attacktarget?username=badfoo&password=badfoo">
<input type="hidden" name="username" value="badfoo">
<input type="hidden" name="password" value="badfoo">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Os erros do PHP que são exibidos normalmente, podem ser bastante úteis para 
    um desenvolvedor que está tentando debugar um script, indicando tais
    erros conforme a função ou o arquivo que falhe, o PHP guarda o arquivo
    que fracassou e o número da linha que houve a falha. Está é toda a informação
    que pode ser explorada. Não é incomum para um desenvolvedor  de php utilizar
     <function>show_source</function>,
    <function>highlight_string</function>, ou
    <function>highlight_file</function> como uma medida de verificação de bugs, 
    mas em um site online, isto pode expor variáveis escondidas, sintaxe que não foi
    verificada, e outras informações perigosas. Especialmente perigoso é rodar o
    código de fontes conhecidos com debugadores imbutidos, ou usando técnicas de
    debugging conhecidas. Se o atacante pode determinar qual é a técnica comum que
    você está usando, ele pode tentar forçar uma página, enviando várias strings
    de debugging comuns:
    
    <example>
     <title>Explorando variáveis de debugging comuns</title>
     <programlisting role="php">
<![CDATA[
<form method="POST" action="attacktarget?errors=Y&amp;showerrors=1&amp;debug=1">
<input type="hidden" name="errors" value="Y">
<input type="hidden" name="showerrors" value="1">
<input type="hidden" name="debug" value="1">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Sem ligação com o método de manipulação de erro, a habilidade de investigar
    um sistema a procura de erros conduz o atacante a mais informação.
   </para>
   <para>
    Por exemplo, o estilo extremo de um erro de PHP genérico indica que um
    sistema está rodando PHP. Se o atacante estava procurando uma página
    .html, e procurou investigar pelo back-end (procurar por fraquezas conhecidas
    no sistema), inserindo nele dados errados ele pode estar apto a determinar
    que o sistema foi construído com PHP.
   </para>
   <para>
    Uma função de erro pode indicar se um sistema pode estar rodando um
    gerenciador específico de banco de dados, ou dar dicas de como um site
    está programado ou projetado. Isto leva em consideração uma investigação mais profunda
    dentro das portas do banco de dados abertas, ou a procura por bugs específicos ou
    fraquezas em uma página web. Inserindo diferentes pedaços de dados ruins, por 
    exemplo, um atacante pode determinar a ordem de autenticação em um script,
    (pelo do número da linha dos erros) tão bem como investigar ações que podem
    ser exploradas em diferentes localizações no script.
   </para>
   <para>
    Um sistema de arquivos ou erros gerais de PHP podem indicar quais permissões
    o servidor web possui, bem como a estrutura e organização dos arquivos
     no servidor web. O código de erro esrito pelo desenvolvedor pode
     agravar este problema, conduzindo a uma exploração fácil de dados
     anteriormente "escondidos".
   </para>
   <para>
    Há três soluções principais para este assunto. A primeiro é examinar
    todas as funções, e tentar compensar pelo volume de erros. A segunda é
    desabilitar exibição de erros completamente no código em execução. A terceira
     é usar funções de manipulação de erros personalizadas do PHP para criar
     seu próprio manipulador de erro. Dependendo de sua política de segurança,
      você pode achar que todas as três são aplicáveis a sua situação.
   </para>
   <para>
    Uma forma de entender este assunto rapidamente é fazer uso do próprio
    relatório de erros do PHP <function>error_reporting</function>, para te
    ajudar dar segurança a seu código, anterior ao planejamento, com E_ALL,
    você pode  rapidamente encontrar áreas onde suas variáveis podem ser
    abertas para envenenamento ou modificação de outras maneiras. Uma vez que
    você já planejou, com o uso de E_NONE, você isola seu código de investidas.
    <example>
     <title>Encontrando variáveis perigosas com E_ALL</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($username) {  // Não inicializada ou verificada antes do uso
    $good_login = 1;
}
if ($good_login == 1) { // Se o teste acima falha, não inicializou ou verificou antes do uso
    readfile ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="security.registerglobals">
   <title>Usando Register Globals</title>
   <para>
    Talvez a mudança mais controversa no PHP é quando o valor padrão para a 
    diretiva do PHP <link linkend="ini.register-globals">
    register_globals</link> passou de ON para OFF no PHP 
    <ulink url="&url.php.release4.2.0;">4.2.0</ulink>.  Confiança nesta
    está diretiva foi bastante pública e muitas pessoas nem mesmo sabiam que
    ela existia e assumiam que ela é apenas a forma como o PHP trabalha.
    Esta página irá explicar como alguém pode escrever um código inseguro com 
    esta diretiva, mas mantenha em mente que a diretiva por si só não é insegura,
    mas o seu uso incorreto sim.
    </para>
   <para>
    Quando on, register_globals injetará (veneno) em seus scripts todos os
    tipos de variáveis, como variáveis request de formulários HTML. Isto 
    junta-se com o fato deo PHP não exigir inicialização de variáveis siginifica
    que escrever códigos inseguros é muito mais fácil. Não foi uma decisão difícil,
     mas a comunidade PHP decidiu, por definição, desabilitar esta diretiva. Quando
     on, as pessoas usavam variáveis ainda sem saber realmente, com certeza, de onde 
     elas vinham e podiam apenas supor. Variáveis internas que estão definidas no próprio
     script conseguem se misturar com dados requisitados enviados pelos usuários e 
     desabilitando register_globals muda isto. Vamos demonstrar com um exemplo de mal uso
     de register_globals:
   </para>
   <para>
    <example>
     <title>Exemplo de uso incorreto com register_globals = on</title>
     <programlisting role="php">
<![CDATA[
<?php
// definir $authorized = true apenas se o usuário está autenticado
if (authenticated_user()) {
    $authorized = true;
}

// Por isso nós primeiro não inicializamos $authorized como false, isto poderia
// ser definido através de register_globals, como por GET auth.php?authorized=1 
// então, qualquer um pode ser visto como autenticado!
if ($authorized) {
    include "/highly/sensitive/data.php";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Quando register_globals = on, nossa lógica acima pode ser comprometida. Quando
    off, <varname>$authorized</varname> não pode ser setada via request portanto isto
    é mais agradável, apesar disso é realmente uma boa prática de programação inicializar as
    variáveis primeiro. Por exemplo, em nosso exemplo acima nós poderíamos ter feito
    primeiro <literal>$authorized = false</literal>.  Fazendo isto primeiro significa
     que nosso código acima trabalharia com register_globals on ou off enquanto usuários,
     por definição, estariam desautorizados.
   </para>
   <para>
    Um outro exemplo é aquele das <link linkend="ref.session">sessões</link>.
    Quando register_globals = on, nós poderíamos também usar
    <varname>$username</varname> em nosso exemplo abaixo, mas novamente você deve
    imaginar que <varname>$username</varname> poderia, também, vir de outros meios, tal
    como  GET (pela URL).
   </para>
   <para>
    <example>
     <title>Exemplo de uso de sessões com register_globals on ou off</title>
     <programlisting role="php">
<![CDATA[
<?php
// Nós saberíamos de onde $username veio, mas fazer com $_SESSION é 
// para dados de sessão 
if (isset($_SESSION['username'])) {
    
    echo "Olá <b>{$_SESSION['username']}</b>";

} else {
    
    echo "Olá <b>Guest</b><br />";
    echo "Você gostaria de logar?";

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    É até possível tomar medidas preventivas para quando a formação de variável 
    está sob tentativa. Se você já sabe de antemão de onde a variável está vindo,
    você pode ver se os dados submetidos está vindo de um tipo de submissão 
    impróprio. Enquanto não está garantido que dados não foram formados,
    ele exige a um atacante que advinhe o tipo correto de formação da variável.
    Se você toma cuidado de onde os dados requisitados vêm, você pode usar 
    <varname>$_REQUEST</varname> já que ele contém um misto de dados GET, POST e
    COOKIE. Veja também a seção do manual sobre usando
     <link linkend="language.variables.external">variáveis externas do PHP</link>. 
   </para>
   <para>
    <example>
     <title>Detectando simples envenamento de variável</title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['MAGIC_COOKIE'])) {
    
    // MAGIC_COOKIE vem de um cookie.
    // Certifique se de validar os dados de cookies!

} elseif (isset($_GET['MAGIC_COOKIE']) || isset($_POST['MAGIC_COOKIE'])) {
   
   mail("admin@example.com", "Possível tentativa de transgressão", $_SERVER['REMOTE_ADDR']);
   echo "Violação da segurança, admin foi alertado.";
   exit;

} else {
   
   // MAGIC_COOKIE não é setado por este REQUEST

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    É claro que, simplesmente desligando register_globals não significa que seu código
    está seguro. Para cada peça de dados que é submetido, ele também seria verificado
    de outras formas. Sempre faça a validação de dados de seus usuários e inicialize 
    as suas variáveis! Para verificar por variáveis  não inicializadas você pode ligar
    <function>error_reporting</function> para mostrar
    níveis de erros <constant>E_NOTICE</constant>.
   </para>
   
   &note.superglobals;

  </sect1>


  <sect1 id="security.variables">
   <title>Dados Submetidos pelo Usuário</title>
   <para>
    A maior fraqueza dos muitos programas em PHP não está inerentemente em 
    sua própria linguagem, mas puramente pelo fato do código não está sendo
    escrito com segurança em mente. Por está razão, você sempre levaria tempo
    para considerar as implicações de uma dada parte do código, para averiguar
    o possível dano se uma variável inesperada é submetida nele.
    <example>
     <title>Uso de Variável Perigosa</title>
     <programlisting role="php">
<![CDATA[
<?php
// remove um arquivo de diretório home do usuário... ou talvez
// alguém?
unlink ($evil_var);

// Escreve o log de seus acessos... ou talvez uma entrada  /etc/passwd?
fputs ($fp, $evil_var);

// Executa algo trivial.. ou rm -rf *?
system ($evil_var);
exec ($evil_var);

?>
]]>
     </programlisting>
    </example>
    Você sempre examinaria cuidadosamente seu código para certificar-se que
    quaisquer variáveis sendo submetidas de um navegador estão sendo verificadas
    adequadamente, e faça a você mesmo os seguintes questionamentos:
    
    <itemizedlist>
     <listitem>
      <simpara>
       Este script afetarár apenas os arquivos intensionados?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Dados incomuns ou indesejáveis podem agir?
      </simpara>
     </listitem>
     <listitem>
     <simpara>
       Este script pode ser usado de maneiras sem propósito?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Este script pode ser usado com outros scripts de maneira indevida?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Quaisquer transações serão adequadamente registradas?
      </simpara>
     </listitem>
    </itemizedlist>
    Respondendo adequadamente estas perguntas enquanto escreve seu script,
    melhor do que depois, você evita uma re-escrita desagradável quando você
     precisar aumentar sua segurança. 
    you prevent an unfortunate re-write when you
    need to increase your security. Começando com esta atitude,
    você não garantirá a segurança de seu sistema, mas você pode ajudar
    a aumentá-la.
   </para>
   <para>
    Você pode também querer desligar register_globals, magic_quotes, ou outras
    configurações convenientes que podem te confundir com a validação, arquivos fontes, ou
    o valor de certas variáveis. Trabalhando com o PHP no modo error_reporting(E_ALL) pode 
    também ajudar a prevenir você, sobre variáveis sendo usadas antes de serem verificadas ou
    inicializadas (então você pode se prevenir de dados sendo lançados)
   </para>
  </sect1>

  <sect1 id="security.hiding">
   <title>Escondendo o PHP</title>
   <para>
    Em geral, segurança por obscuridão é uma das mais fracas formas de segurança.
    Mas em alguns casos, cada pequeno bit extra de segurança é desejável.
   </para>
   <para>
    Algumas poucas técnicas simples podem ajudar a esconder o PHP, possivelmente
    atrasando um invasor que está tentando descobrir fraquezas em seu sistema. 
    Setando expose_php = off em seu arquivo &php.ini;, você reduz a quantidade de 
    informação disponível para ele.
   </para>
   <para>
    Uma outra tática é configurar os servidores tais como apache para
    interpretar diferentes tipos de arquivos através do PHP, ou com uma diretiva
     &htaccess;, ou na própria configuração do apache. Você pode então usar extensões
      de arquivos enganadoras:
    <example>
     <title>Escondendo PHP fazendo parecer com outra linguagem</title>
     <programlisting role="apache-conf">
<![CDATA[
# Fazer o código PHP parecer com outros tipos de códigos
AddType application/x-httpd-php .asp .py .pl
]]>
     </programlisting>
    </example>
   Ou escondê-lo completamente:
    <example>
     <title>Usando tipos desconhecidos para extensões do PHP</title>
     <programlisting role="apache-conf">
<![CDATA[
# Fazer o código PHP parecer com tipos de códigos desconhecidos
AddType application/x-httpd-php .bop .foo .133t
]]>
     </programlisting>
    </example>
    Ou escondê-lo no código HTML, que tem baixa chance de ser atingido porque
    todos os HTML serão interpretados pelo PHP:
    <example>
     <title>Usando tipos de HTML para extensões do PHP</title>
     <programlisting role="apache-conf">
<![CDATA[
# Fazer todo o código parecer com HTML
AddType application/x-httpd-php .htm .html
]]>
     </programlisting>
    </example>
    Para este exemplo trabalhar efetivamente, você deve renomeiar todos os 
    seus arquivos PHP com as extensões acimas. Apesar dessa ser a forma de
     segurança através obscuridão, ela é a medida menos preventiva e com 
     algumas desvantagens.
   </para>
  </sect1>

  <sect1 id="security.current">
   <title>Permanecendo atualizado</title>
   <simpara>
    O PHP, como outro grande sistema qualquer, está sob constante exames e
    melhoramentos. Cada nova versão, muitas vezes, incluirá  maiores e menores
    mudanças para aumentar e reparar falhas de segurança, configuração, e outros
    assuntos que afetarão a completa segurança e estabilidade de seu sistema.
   </simpara>
   <simpara>
    Como outra linguagem e programas de scripting a nível de sistema, a melhor
    aproximação é atualizar freqüentemente, e ter a consciência da última versão
    e de suas mudanças.
   </simpara>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
