<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
 <reference id="ref.mhash">
  <title>Mhash Functions</title>
  <titleabbrev>mhash</titleabbrev>
  
  <partintro>
   <para>
    Estas funções tem a intenção de funcionar com
    <ulink url="&url.mhash;">mhash</ulink>.</para>
   <para>
    Esta é uma interface para a biblioteca mhash. mhash suporta
    uma grande variedade de algoritmos hash como MD5, SHA1, GOST e
    vários outros.
   </para>
   <para>
    Para usalas, faça o download da distribuição mhash do <ulink
    url="&url.mhash;">web site deles</ulink> e siga as instruções
    de instalação inclusas. Você precisará compilar o PHP com o
    parametro <option role="configure">--with-mhash</option> para
    habilitar esta extensão.
   </para>
   <para>
    Mhash pode ser usado para criar checksums, message digests, códigos
    de autenticação e mais.
   </para>
   <para>
    <example>
     <title>Computar o MD5 digest e hmac e imprimir como hex</title>
     <programlisting role="php">
<![CDATA[
<?php
$input = "o que você quer por nada?";
$hash = mhash (MHASH_MD5, $input);
print "A hash é ".bin2hex ($hash)."\n&lt;br>";
$hash = mhash (MHASH_MD5, $input, "Jefe");
print "A hmac é ".bin2hex ($hash)."\n&lt;br>";
?>
]]>
     </programlisting>
     <para>
      Este código irá produzir:
      <screen>
<![CDATA[
A hash é d03cb659cbf9192dcd066272249f8412 
A hmac é 750c783e6ab0b503eaa86e310a5db738 
]]>
      </screen>
     </para>
    </example>
    Para uma lista completa de hashes suportadas, refira-se para a
    documentação do mhash. A regra geral é que você pode acessar o
    algoritmo hash do PHP com MHASH_HASHNAME. Por exemplo, para
    accessar TIGER se usa a constante do PHP MHASH_TIGER.
   </para>
   <para>
    Aqui está a lista de hashes que são atualmente suportadas por mhash.
    Se uma hash não está listada aqui, mas é listada por mhash como
    suportada, você pode com seguranca presumir que esta documentação está
    desatualizada.
    <itemizedlist>
     <listitem>
      <simpara>
       MHASH_MD5
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_SHA1
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_HAVAL256
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_HAVAL192
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_HAVAL160
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_HAVAL128
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_RIPEMD160
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_GOST
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_TIGER
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_CRC32
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       MHASH_CRC32B
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
  </partintro>
  
  <refentry id="function.mhash-get-hash-name">
   <refnamediv>
    <refname>mhash_get_hash_name</refname>
    <refpurpose>Ler o nome da hash especificada</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrição</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>mhash_get_hash_name</function></funcdef>
      <paramdef>int <parameter>hash</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>mhash_get_hash_name</function> é usada para obter o nome
     da hash especificada.
    </para>
    <para>
     <function>mhash_get_hash_name</function> recebe a id da hash como um
     argumento e retorna o nome da hash ou &falsel;, se a hash não existe.
    </para>
    <para>
     <example>
      <title>Exemplo do <function>mhash_get_hash_name</function></title>
      <programlisting>
<![CDATA[
<?php
$hash = MHASH_MD5;

print mhash_get_hash_name ($hash);
?>
]]>
      </programlisting>
      <para>
       O exemplo acima irá imprimir:
       <screen>
<![CDATA[
      MD5
]]>
       </screen>
      </para>
     </example>
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="function.mhash-get-block-size">
   <refnamediv>
    <refname>mhash_get_block_size</refname>
    <refpurpose>Ler o tamanho do bloco da hash específicada</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrição</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>mhash_get_block_size</function></funcdef>
      <paramdef>int <parameter>hash</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>mhash_get_block_size</function> é usada para obter o
     tamanho de um blobo da <parameter>hash</parameter> específicada.
    </para>
    <para>
     <function>mhash_get_block_size</function> recebe um argumento, a
     <parameter>hash</parameter> e retorna o tamanho em bytes ou
     &false;, se o parametro <parameter>hash</parameter> não existe.
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="function.mhash-count">
   <refnamediv>
    <refname>mhash_count</refname>
    <refpurpose>Ler o mais alto hash id disponível</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrição</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>mhash_count</function></funcdef>
      <void/>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>mhash_count</function> retorna a mais alta hash id disponível.
     As hashes são numeradas de 0 até esta hash id.
    </para>
    <para>
     <example>
      <title>Listando todas as hashes</title>
      <programlisting role="php">
<![CDATA[
<?php

$nr = mhash_count();

for ($i = 0; $i <= $nr; $i++) {
    echo sprintf ("O tamanho do bloco de %s é %d\n", 
        mhash_get_hash_name ($i),
        mhash_get_block_size ($i));
}
?>
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>
    
  <refentry id="function.mhash">
   <refnamediv>
    <refname>mhash</refname>
    <refpurpose>Computar a hash</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrição</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>mhash</function></funcdef>
      <paramdef>int <parameter>hash</parameter></paramdef>
      <paramdef>string <parameter>data</parameter></paramdef>
      <paramdef>string <parameter>[ key ]</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>mhash</function> applica a função hash especificada por
     <parameter>hash</parameter> para o parametro <parameter>data</parameter>
     e retorna a hash resultante (também chamada de digest). Se a
     <parameter>key</parameter> for especificada a função irá retornar o
     HMAC resultante. HMAC é o hashing com chave (keyed) para autenticações
     de mensagens, ou simplesmente um digest de mensagens que depende na
     chave (key) específicada. Nem todos os algorítmos suportados em mhash
     podem ser usados em modo HMAC. Em caso de erro retorna &false;.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.mhash-keygen-s2k">
   <refnamediv>
    <refname>mhash_keygen_s2k</refname>
    <refpurpose>Gerar uma chave</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrição</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>mhash_keygen_s2k</function></funcdef>
      <paramdef>int <parameter>hash</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string <parameter>salt</parameter></paramdef>
      <paramdef>int <parameter>bytes</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>mhash_keygen_s2k</function> gera um chave que tem
     <parameter>bytes</parameter> de comprimento, apartir de uma
     senha (password) do usuário. Este é o algoritmo Salted S2K
     como especificado no documento OpenPGP (RFC 2440). Este 
     algoritmo usará o algoritmo <parameter>hash</parameter> 
     para criar a chave. O <parameter>salt</parameter> deve ser
     diferente e aleatório o suficiente para que cada chave que
     você gere seja diferente. Este salt tem que ser sabido quando
     você checar as suas chaves (keys), logo é uma boa ideia
     que a chave siga o salt. O salt tem o comprimento fixo de 8
     bytes e será completado com zeros se voce fornecer menos bytes.
     Tenha em mente que as senhas fornecidas pelos usuários não são
     boas para serem usadas como chaves em algoritmos criptográficos,
     pois usuários normalmente escolhem chaves que eles podem escrever
     no teclado. Estas senhas usam somente 6 a 7 bits por caracter
     (ou menos). É altamente recomendado usar algum tipo de 
     transformação (como esta função) na chave dada pelo usuário.
    </para>
   </refsect1>
  </refentry>

 </reference> 

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
