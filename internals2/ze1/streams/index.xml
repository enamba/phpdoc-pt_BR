<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.3 Maintainer: narigone Status: ready -->
<!-- Author: Wez Furlong <wez@thebrainroom.com>
  Please contact me before making any major amendments to the
  content of this section.  Splitting/Merging are fine if they are
  required for php-doc restructuring purposes - just drop me a line
  if you make a change (so I can update my local copy).
-->

<chapter xml:id="streams" xmlns="http://docbook.org/ns/docbook">
 <title>Autores da Extensão do PHP, a API de Fluxos (Streams)</title>

 <sect1 xml:id="streams.overview">
  <title>Overview</title>
  <para>
   A API de Fluxos de Dados do PHP introduz uma maneira unificada de lidar com
   arquivos e sockets em extensões do PHP. Usando uma API única, com funções
   padrões para operações comuns, a API de fluxos permite que sua extensão
   acesse arquivos, sockets, URLs, memória e objetos definidos pelo script.
   Essa API é extensível em tempo de execução que permite carregar dinâmicamente
   módulos (e scripts!) para registrar novos fluxos.
  </para>
  <para>
   O objetivo da API de fluxos é tornar confortável para os desenvolvedores
   abrir arquivos, URLs e outras fontes de dados com uma API unificada
   que é fácil de compreender. A API é mais ou menos baseada na família de
   funções da biblioteca ANSI C stdio (com semântica idêntica para a maioria das
   principais funções), então programadores C terão um sentimento de familiaridade com fluxos.
  </para>
  <para>
    A API de fluxos opera em alguns níveis diferentes: no nível base, a
    API define objetos php_stream pare representar fontes de dados streamable.
    Em um nível um pouco acima, o API define objetos  php_stream_wrapper
    que fazem um "wrap" no nível mais baixo da API para prover suporte para pegar
    dados e meta-dados de URLs. Um parâmetro <literal>context</literal> adicional,
    aceito para a maioria das funções de criação de fluxos, é passada para o 
    método <literal>stream_opener</literal> do wrapper para afinar o comportamento
    do mesmo.
  </para>
  <para>
   Qualquer fluxo, uma vez aberto, também pode ter um número qualquer de <literal>filters</literal> (filtros)
   aplicados ao mesmo, que processa os dados enquanto lê do/escreve no fluxo.
  </para>
  <para>
   Fluxos podem ser convertidos em outros tipos de file-handles, para que eles
   possam ser usados por bibliotecas de terceiros sem muito trabalho. Isso
   permite que essas bibliotecas acessem dados diretamente de fontes URL. Se seu
   sistema tem as funções <function>fopencookie</function> ou
   <function>funopen</function> , você pode até passar
   qualquer fluxo PHP para qualquer biblioteca que use a stdio ANSI!
  </para>
  <para>
   <note>
    <para>
     As funções nesse capítulo são para uso no código-fonte do PHP e não
     são funções PHP. Funções de fluxo para usuários podem ser encontrados na
     <link linkend="ref.stream">Referência de Fluxos de Dados</link>.
    </para>
   </note>
  </para>
 </sect1>

 <sect1 xml:id="streams.basics">
  <title>Basico de Fluxos de Dados</title>
  <para>
   Usar fluxos de dados é muito parecido com usar a funções da stdio ANSI. A diferença
   principal é como você obtem um handle de fluxo para começar.
   Na maioria dos casos, você usará <function>php_stream_open_wrapper</function>
   para obter esse handle. Essa função funciona de forma análoga à fopen,
   como pode ser visto no exemplo abaixo:
  </para>
  <para>
     <example>
      <title>Exemplo simples de fluxo de dados que mostra a página do PHP</title>
      <programlisting role="c">
<![CDATA[
php_stream * stream = php_stream_open_wrapper("http://www.php.net", "rb", REPORT_ERRORS, NULL);
if (stream) {
    while(!php_stream_eof(stream)) {
        char buf[1024];
        
        if (php_stream_gets(stream, buf, sizeof(buf))) {
            printf(buf);
        } else {
            break;
        }
    }
    php_stream_close(stream);
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
   A tabela abaixo mostra os fluxos equivalentes para as funções mais comuns da stdio ANSI.
   A não ser que esteja comentado o contrário, as semânticas das funções são idênticas.
     <table>
      <title>Funções equivalentes à stdio ANSI na API de Fluxos de Dados</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Função stdio ANSI</entry>
         <entry>Função de Fluxo de Dados do PHP</entry>
         <entry>Comentário</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>fopen</entry>
         <entry>php_stream_open_wrapper</entry>
         <entry>A API inclui parâmetros adicionais</entry>
        </row>

        <row>
         <entry>fclose</entry>
         <entry>php_stream_close</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fgets</entry>
         <entry>php_stream_gets</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fread</entry>
         <entry>php_stream_read</entry>
         <entry>O parâmetro nmemb tem o valor de 1, então o protótipo parece mais com read(2)</entry>
        </row>

        <row>
         <entry>fwrite</entry>
         <entry>php_stream_write</entry>
         <entry>O parâmetro nmemb tem o valor de 1, então o protótipo parece mais com write(2)</entry>
        </row>

        <row>
         <entry>fseek</entry>
         <entry>php_stream_seek</entry>
         <entry></entry>
        </row>

        <row>
         <entry>ftell</entry>
         <entry>php_stream_tell</entry>
         <entry></entry>
        </row>

        <row>
         <entry>rewind</entry>
         <entry>php_stream_rewind</entry>
         <entry></entry>
        </row>

        <row>
         <entry>feof</entry>
         <entry>php_stream_eof</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fgetc</entry>
         <entry>php_stream_getc</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fputc</entry>
         <entry>php_stream_putc</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fflush</entry>
         <entry>php_stream_flush</entry>
         <entry></entry>
        </row>

        <row>
         <entry>puts</entry>
         <entry>php_stream_puts</entry>
         <entry>Mesma semântica de puts, NÂO de fputs</entry>
        </row>

        <row>
         <entry>fstat</entry>
         <entry>php_stream_stat</entry>
         <entry>A API tem uma estrutura stat mais rica</entry>
        </row>
         
       </tbody>
      </tgroup>
     </table>
   
  </para>
 </sect1>

 <sect1 xml:id="streams.resources">
  <title>Fluxos como Recursos</title>
  <para>
   Todos os fluxos são registrados como recursos quando são criados. Isso assegura
   que eles serão apropriadamente limpos mesmo que ocorra um erro fatal.
   Todas as funções que lidam com o sistema de arquivos no PHP operam com recuros de fluxos - o
   que significa que suas extensões podem aceitar ponteiros de arquivo PHP normais, como
   parâmetros para a função e como parâmetros de retorno também.
   A API de fluxos faz esse processo da maneira mais suave possível:
  </para>
  <para>
     <example>
      <title>Como aceitar um fluxo como parâmetro</title>
      <programlisting role="c">
<![CDATA[
PHP_FUNCTION(example_write_hello)
{
    zval *zstream;
    php_stream *stream;
    
    if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &zstream))
        return;
    
    php_stream_from_zval(stream, &zstream);

    /* Agora você pode usar o fluxo. No entanto, você não "possui" o 
        fluxo, mas sim o script. Isso quer dizer que você NÃO DEVE fechar o
        fluxo, porque isso causará que o PHP sofra um crash! */

    php_stream_write(stream, "hello\n");
        
    RETURN_TRUE();
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
     <example>
      <title>Como retornar um fluxo de uma função</title>
      <programlisting role="c">
<![CDATA[
PHP_FUNCTION(example_open_php_home_page)
{
    php_stream *stream;
    
    stream = php_stream_open_wrapper("http://www.php.net", "rb", REPORT_ERRORS, NULL);
    
    php_stream_to_zval(stream, return_value);

    /* a partir desse ponto, o fluxo é do script. 
        Fechá-lo resultará no PHP sofrendo um crash! */
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
   Uma vez que fluxos são limpados automaticamente, é tentador achar que podemos 
   ser programadores descuidados e não nos preocupar em limpar os fluxos quando
   terminamos com eles. Embora essa abordagem possa funcionar, não é uma boa idéia
   por um número de razões: fluxos de dados travam recursos do sistema enquanto
   abertos, então deixa um arquivo aberto após ter terminado de usá-lo pode fazer com que
   outros processos não possam acessá-lo. Se um script lida com um número grande de arquivos,
   a acumulação de recursos usados, ambos em termos de memória e de
   arquivos abertos, pode causar que a requisição ao servidor web falhe. Parece
   ruim, não é? A API de fluxos inclui algumas mágicas que ajudam você a
   manter o código limpo - se um fluxo não for fechado pelo seu código quando deveria,
   você encontrará algumas informações úteis para depuração no log de erro do servidor
   web.
  </para>
  <note>
   <simpara>
    Sempre use um binário com símbolos de depuração quando estiver desenvolvendo uma extensão
    (<option>--enable-debug</option> quando executar configure), já que vários
    esforços foram feitos para avisá-lo sobre vazamentos de memória e de fluxos.
   </simpara>
  </note>
  <para>
   Em alguns casos, é útil para manter o fluxo aberto durante toda duração da requisição,
   para agir como um registro (log) por exemplo. Escrever o código para limpar de maneira segura
   esse fluxo não é difícil, mas são várias linhas de código que não são
   necessárias. Para poupar o trabalho de escrever o código, você 
   pode marcar um fluxo para auto limpeza. Isso significa que
   a API de fluxos não emitirá um aviso quando chegar a hora de limpar automaticamente
   um fluxo. Para isso, você pode usar a função <function>php_stream_auto_cleanup</function>.
  </para>
 </sect1>

<!-- Disable these until references are fixed
 &internals2.ze1.streams.common;
 &internals2.ze1.streams.dir;
 &internals2.ze1.streams.file;
 &internals2.ze1.streams.socket;
 &internals2.ze1.streams.structs;
-->
 &internals2.ze1.streams.constants;
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

