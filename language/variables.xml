<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.49 Maintainer: ae Status: ready -->
 <chapter id="language.variables">
  <title>Variáveis</title>

  <sect1 id="language.variables.basics">
   <title>Introdução</title>

   <simpara>
    As variáveis no PHP são representadas por um cifrão ($) seguido pelo
    nome da variável. Os nomes de variável no PHP fazem distinção entre maiúsculas e minúsculas.
   </simpara>

   <para>
    Os nomes de variável seguem as mesmas regras como outros rótulos no PHP.
    Um nome de variável válido se inicia com uma letra ou sublinhado, seguido
    de qualquer número de letras, algarismos ou sublinhados.  Em uma
    expressão regular isto poderia ser representado desta forma:
    '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
   </para>

   <note>
    <simpara>
     Para nossos propósitos, as letras a-z, A-Z e os caracteres
     ASCII de 127 a 255 (0x7f-0xff).
    </simpara>
   </note>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$var = "Bob";
$Var = "Joe";
echo "$var, $Var";      // exibe "Bob, Joe"

$4site = 'not yet';     // inválido; começa com um número
$_4site = 'not yet';    // válido; começa com um sublinhado
$täyte = 'mansikka';    // válido; 'ä' é um caracter ASCII 228.
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    No PHP 3, as variáveis são sempre atribuídas por valor. Isto significa
    que quando você atribui uma expressão a uma variável, o valor
    da expressão original é copiado integralmente para a variável de destino.
    Isto significa também que, após atribuir o valor de uma variável a
    outra, a alteração de uma destas variáveis
    não afetará a outra. Para maiores informações sobre este tipo de
    atribuição, veja <link
    linkend="language.expressions">Expressões</link>.
   </para>
   <para>
    O PHP 4 oferece um outro meio de atribuir valores a variáveis: a
    <emphasis>atribuição por referência</emphasis>. Isto significa que
    a nova variável simplesmente referencia (em outras palavras, "torna-se
    um apelido para" ou "aponta para") a variável original.  Alterações na
    nova variável afetam a original e vice versa.  Isto significa também que
    nenhuma cópia é realizada, de modo que a atribuição ocorre mais rapidamente.
    Entretanto, qualquer aumento de velocidade só será realmente notado
    em *loops* complexos ou em atribuições de grandes matrizes (*arrays*) ou objetos.
   </para>
   <para>
    Para atribuir por referência, simplesmente adicione um e-comercial (&amp;)
    na frente do nome da variável que estiver sendo atribuída (variável
    de origem) Por exemplo, o trecho de código abaixo imprime 'My
    name is Bob' duas vezes:

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 'Bob';              // Atribui o valor 'Bob' a variável $foo
$bar = &$foo;              // Referecia $foo através de $bar.
$bar = "My name is $bar";  // Altera $bar...
echo $bar;
echo $foo;                 // $foo é alterada também.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Uma observação importante a se fazer: somente variáveis
    nomeadas podem ser atribuídas por referência.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 25;
$bar = &$foo;      // Esta atribuição é válida.
$bar = &(24 * 7);  // Inválido; referencia uma expressão sem nome.

function test()
{
   return 25;
}

$bar = &test();    // Inválido.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

  </sect1>

  <sect1 id="language.variables.predefined">
   <title>Variáveis Predefinidas</title>

   <simpara>
    O PHP oferece um grande número de variáveis predefinidas para qualquer script
    que ele execute. Muitas destas variáveis, entretanto, não podem ser completamente
    documentadas uma vez dependem de diversos fatores, como o servidor no qual scripts são executados, a
    versão e configuração deste servidor e outros. Algumas destas
    variáveis não estarão disponíveis quando o PHP for executado na linha de
    comando. Para uma lista destas variáveis, veja a seção
    <link linkend="reserved.variables">Variáveis reservadas</link>.
   </simpara>

   <warning>
    <simpara>
     No PHP 4.2.0 e posteriores, a variedade de variáveis predefinidas
     disponíveis no escopo global foi modificada. Parâmetros
     individuais e variáveis do servidor <emphasis>por default não</emphasis>
     são disponíveis diretamente no escopo global: elas são
     colocadas dentro dos <link
     linkend="language.variables.superglobals">arrays
     superglobais</link>.
    </simpara>
    <simpara>
     Você também pode forçar o antigo comportamento configurando <link
     linkend="ini.register-globals">register_globals</link> para 'On' em
     seu arquivo &php.ini;.
    </simpara>
    <simpara>
     Para maiores informações desta modificação, veja 
     o <ulink url="&url.php.release4.1.0;">PHP 4.1.0 Release
     Announcement</ulink>.
    </simpara>
   </warning>

   <simpara>
    Desde a versão 4.1.0, o PHP fornece um conjunto de arrays predefinidos
    contendo as variáveis do servidor web (se aplicável), as
    variáveis ambiente e as entradas do usuário. Esses novos arrays são especiais
    pelo motivo que são automaticamente globais (significa que são automaticamente
    disponíveis em qualquer escopo. Por causa disso, são também conhecidas como
    'autoglobais' ou 'superglobais' (Não há um mecanismo no PHP para
    superglobais definidas pelo usuário) As superglobais são listadas abaixo.
    Entretanto, para uma explicação de seu conteúdo e detalhes sobre
    as variáveis predefinidas do PHP e sua natureza, veja a seção
    <link linkend="reserved.variables">Variáveis Predefinidas</link>.
   </simpara>

   <para>
    Se todos os indicadores não estiverem configurados no <link
    linkend="ini.variables-order">variables_order</link>, seus
    arrays superglobais respectivos estarão vazios.
   </para>

   <variablelist id="language.variables.superglobals">
    <title>Superglobais do PHP</title>
    <varlistentry>
     <term><link linkend="reserved.variables.globals">$GLOBALS</link></term>
     <listitem>
      <simpara>
       Contém um referência para todas as variáveis que são atualmente
       disponíveis dentro do escopo global do script. As chaves
       desse array são os nomes das variáveis globais.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.server">$_SERVER</link></term>
     <listitem>
      <simpara>
       Variáveis criadas pelo servidor web ou diretamente relacionadas
       ao ambiente de execução do script atual. Análogo
       ao antigo array <varname>$HTTP_SERVER_VARS</varname> (que
       ainda continua disponível, mas em decadência).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.get">$_GET</link></term>
     <listitem>
      <simpara>
       Variáveis postadas para o script via método HTTP GET. Análogo ao
       antigo array <varname>$HTTP_GET_VARS</varname> (que
       ainda continua disponível, mas em decadência).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.post">$_POST</link></term>
     <listitem>
      <simpara>
       Variáveis postadas para o script via método HTTP POST. Análogo ao
       antigo array <varname>$HTTP_POST_VARS</varname> (que
       ainda continua disponível, mas em decadência).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.cookies">$_COOKIE</link></term>
     <listitem>
      <simpara>
       Variáveis postadas para o script via cookies HTTP. Análogo ao
       antigo array <varname>$HTTP_COOKIE_VARS</varname> (que
       ainda continua disponível, mas em decadência).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.files">$_FILES</link></term>
     <listitem>
      <simpara>
       Variáveis postadas para o script via transferência de arquivos HTTP.
       Análogo ao antigo array
       <varname>$HTTP_POST_FILES</varname> (que ainda
       continua disponível, mas em decadência). Veja <link
       linkend="features.file-upload.post-method">uploads via
       método POST</link> para maiores informações.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.environment">$_ENV</link></term>
     <listitem>
      <simpara>
       Variáveis disponíveis no script do ambiente de execução. Análogo ao
       antigo array <varname>$HTTP_ENV_VARS</varname> (que
       ainda continua disponível, mas em decadência).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.request">$_REQUEST</link></term>
     <listitem>
      <simpara>
       Variáveis postadas para o script por todas os mecanismos de input,
       e que não podem ter seu conteúdo garantido de qualquer forma. Note: quando executando
       da linha de comando, elas <emphasis>não</emphasis> incluem
       as entidades <varname>argv</varname> e <varname>argc</varname>;
       elas estão presentes no array <varname>$_SERVER</varname>.
       A presença e a ordem de inclusão das variáveis nesse array
       é definida de acordo com a diretiva de configuração <link
       linkend="ini.variables-order">variables_order</link>.
       Este array não tem um equivalente nas
       versões anteriores do PHP 4.1.0.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.session">$_SESSION</link></term>
     <listitem>
      <simpara>
       Variáveis que estão atualmente registradas na sessão do
       script. Análogo ao antigo array
       <varname>$HTTP_SESSION_VARS</varname> (que ainda
       continua disponível, mas em decadência). Veja a sessão <link
       linkend="ref.session">funções de manipulação de Sessões</link>
       para maiores informações.
      </simpara>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect1>


  <sect1 id="language.variables.scope">
   <title>Escopo de variáveis</title>

   <simpara>
    O escopo de uma variável é o contexto onde ela foi definida.
    A maior parte das variáveis do PHP tem somente escopo local.
    Este escopo local inclui os arquivos incluídos. Por
    exemplo:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = 1;
include "b.inc";
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Aqui a variável <varname>$a</varname> estará disponível
    no script incluído <filename>b.inc</filename>. Entretanto, com as
    funções definidas pelo usuário, um escopo local é introduzido. Quaisquer
    variáveis utilizadas dento da função é por default limitada dentro do
    escopo local da função. Por exemplo:
</simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = 1; /* escopo global */

function Teste()
{
    echo $a; /* referencia uma variável do escopo local (não definida) */
}

Test();
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Este script não produz nenhuma saída porque a instrução <function>echo</function>
    refere-se a uma versão local da variável <varname>$a</varname>,
    e ela não tem nenhum valor assimilado nesse escopo. Essa é uma
    pequena diferença da linguagem C quando
    variáveis globais são automaticamente disponíveis para
    funções sem sobreescrever uma eventual definição local.
    Isto causa problemas quando as pessoas mudam
    inadivertidamente uma variável global. No PHP, as variáveis globais precisam ser
    declaradas globais dentro de uma função se ela vai ser utilizada
    naquela função. Um exemplo:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 2;

function Soma()
{
    global $a, $b;

    $b = $a + $b;
}

Soma();
echo $b;
]]>
    </programlisting>
   </informalexample>

   <simpara>
    O script acima imprimirá &quot;3&quot;. Declarando
    <varname>$a</varname> e <varname>$b</varname> globais na
    função, todas as referências a essas variáveis referem-se a
    versão global. Não há um limite para o número de variáveis
    globais que podem ser manipuladas por uma função.
   </simpara>

   <simpara>
    Uma segunda maneira de acessar variáveis do escopo global é utilizando
    o array especial <varname>$GLOBALS</varname> definido pelo PHP. O
    exemplo anterior poderia ser rescrito como:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 2;

function Soma()
{
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
}

Soma();
echo $b;
]]>
    </programlisting>
   </informalexample>

   <simpara>
    <varname>$GLOBALS</varname> é um array associativo em que
    o nome das variáveis globais são suas chaves e o conteúdo dessas
    variáveis são o valor do elemento do array.
   </simpara>

   <simpara>
    Outro recurso importante do escopo de variáveis é a
    variável <emphasis>estática</emphasis>. Uma variável estática existe
    somente no escopo local da função, mas ela não perde seu valor
    quando o nível de execução do programa deixa o escopo. Considere o seguinte
    exemplo:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
function Teste ()
{
    $a = 0;
    echo $a;
    $a++;
}
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Essa função é inútil partindo de que cada vez que ela é chamada, ela
    coloca em <varname>$a</varname> o valor <literal>0</literal> e imprime
    &quot;0&quot;. A instrução <varname>$a</varname>++ , que aumenta o valor da
    variável não tem sentido desde que a função sai e a
    variável <varname>$a</varname> desaparece. Para faze-la mais útil
    como contadora sem deixar de perder o sua conta atual,
    a variável <varname>$a</varname> é declarada como estática:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
function Teste()
{
    static $a = 0;
    echo $a;
    $a++;
}
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Agora, cada vez que a função Teste() for chamada ele imprimirá o
    valor de <varname>$a</varname> e o incrementará.
   </simpara>

   <simpara>
    Variáveis estáticas fornecem uma solução ideal para funções
    recursivas. Uma função recursiva é aquela se chama a si mesma. Cuidados
    especiais precisam ser tomados quando escrevendo funções recursivas porque é
    possível que ela continue na recursão indefinidamente. Você tem de ter certeza
    que há uma maneira segura de terminar a recursão. A seguinte
    função recursiva conta até 10, utilizando a variável
    estática <varname>$count</varname> para saber quando parar:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
function Teste()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        Test ();
    }
    $count--;
}
]]>
    </programlisting>
   </informalexample>

   <simpara>
    O Zend Engine 1, base do <literal>PHP4</literal>, implementa os
    modificadores <literal>static</literal> e <literal>global</literal> para
    variáveis em termos de referência. Por exemplo, uma variável global
    importada dentro do escopo de uma função com a instrução <literal>global</literal>
    atualmente cria uma referência para a variável global. Isto pode causar
    comportamentos impresíveis para os seguintes casos:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Executando esse exemplo você terá as seguites saídas:
   </simpara>

   <screen>
NULL
object(stdClass)(0) {
}
   </screen>

   <simpara>
    Uma situação similar se aplica ao modificador <literal>static</literal>.
    Referências não são armazenadas estaticamente:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
function &get_instance_ref() {
    static $obj;

    echo "Objeto estatico: ";
    var_dump($obj);
    if (!isset($obj)) {
        // Assimila uma referencia a variavel estatica
        $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo "Objeto estatico: ";
    var_dump($obj);
    if (!isset($obj)) {
        // Assimila o objeto para a veriavel estatica
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Executando esse exemplo você terá as seguites saídas:
   </simpara>

   <screen>
Objeto estatico: NULL
Objeto estatico: NULL

Objeto estatico: NULL
Objeto estatico: object(stdClass)(1) {
  ["property"]=>
  int(1)
}
   </screen>

   <simpara>
    Este exemplo demonstra que quando assimilando uma referência para uma variável
    estática, ela <emphasis>não se lembra</emphasis> quando você chama a função
    <literal>&amp;get_instance_ref()</literal> uma segunda vez.
   </simpara>


  </sect1>

  <sect1 id="language.variables.variable">
   <title>Variáveis variáveis</title>

   <simpara>
    As vezes é conveniente poder trabalhar com variáveis
    variáveis. Isto é, nomes de variáveis que pode ser criadas e utilizadas
    dinamicamente. Uma variável normal é criada numa instrução como:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = "hello";
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Uma variável variável pega o valor de uma variável e a trata como
    o nome de uma variável. No exemplo acima,
    <emphasis>hello</emphasis> pode ser utilizada como o nome de uma variável
    utilizando dois sinais de cifrão:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
$$a = "world";
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Neste ponto, duas variáveis foram definidas e preservadas na
    árvore de símbolos do PHP: <varname>$a</varname> contendo "hello" e
    <varname>$hello</varname> contendo "world". Da mesma forma, esta
    instrução:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
echo "$a ${$a}";
]]>
    </programlisting>
   </informalexample>

   <simpara>
    produz a mesma saida que:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
echo "$a $hello";
]]>
    </programlisting>
   </informalexample>

   <simpara>
    no caso: <computeroutput>hello world</computeroutput>.
   </simpara>

   <simpara>
    Para poder utilizar variáveis variáveis com arrays, você precisa
    resolver um problema de ambigüidade. Assim, se você escrever
    <varname>$$a[1]</varname> então o interpretador pode entender que
    você quer usar <varname>$a[1]</varname> como uma variável ou que
    você quer usar <varname>$$a</varname> como uma variável e [1]
    como o índice dessa variável. A sintaxe para resolver essa ambigüidade
    é <varname>${$a[1]}</varname> para o primeiro caso e
    <varname>${$a}[1]</varname> para o segundo.
   </simpara>

   <simpara>
    Verifique que variáveis variáveis não podem ser utilizadas com as novas superglobais do PHP.
    Isto significa que você não pode fazer coisas como <varname>${$_GET}</varname>. Se você está
    procurando uma maneira de manipular as superglobais como as antigas
    HTTP_*_VARS, você deve tentar <link linkend="language.references">referenciá-las</link>.
   </simpara>

  </sect1>

  <sect1 id="language.variables.external">
   <title>Variáveis externas ao PHP</title>

   <sect2 id="language.variables.external.form">
    <title>Formulários HTML (GET and POST)</title>

    <simpara>
     Quando um formulário é submetido para um script PHP, qualquer variável do
     formulário será automaticamente disponível para o script pelo
     PHP. Se a diretiva de configuração <link linkend="ini.track-vars">track_vars</link>
     estiver ativada, então essas variáveis estarão
     localizadas nos arrays associativos
     <varname>$_POST</varname>,
     <varname>$_GET</varname> e/ou
     <varname>$_FILES</varname>, de acordo com
     a fonte da variável em questão.
    </simpara>

    <para>
     Para maiores informações sobre essas veiáveis, veja <link
     linkend="language.variables.predefined">Variáveis
     Predefinidas</link>.
    </para>

    <para>
     <example>
      <title>Variáveis simples de formulários</title>
      <programlisting role="php">
<![CDATA[
<form action="foo.php" method="post">
    Name: <input type="text" name="username"><br>
    <input type="submit">
</form>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Quando o formulário é submetido, o valor da caixa de texto
     estará disponível em
     <varname>$_POST['username']</varname>. Se a diretiva de configuração <link
     linkend="ini.register-globals">register_globals</link>
     estiver ativada, então a estará disponível
     a variável <varname>$username</varname> no escopo global.
    </para>

    <note>
     <para>
      A diretiva de configuração <link linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link>
      afeta os valores de GET, POST e Cookies. Se
      estiver ativada, o valor (It's "PHP!") se tornará automaticamente (It\'s \"PHP!\").
      Escaping é necessário para inserção em bancos de dados. Veja também
      <function>addslashes</function>, <function>stripslashes</function> e
      <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
     </para>
    </note>

    <simpara>
     O PHP entende arrays no contexto de variáveis de formulários
     (veja o <link linkend="faq.html">FAQ</link> relacionado). Você pode,
     por exemplo, agrupar variáveis relacionadas juntas, ou usar
     esse recurso para receber valores de um campo de seleção múltipla.
    </simpara>

    <para>
     <example>
      <title>Variáveis de formulários complexos</title>
      <programlisting role="php">
<![CDATA[
<form action="array.php" method="post">
    Name: <input type="text" name="personal[name]"><br>
    Email: <input type="text" name="personal[email]"><br>
    Beer: <br>
    <select multiple name="beer[]">
        <option value="warthog">Warthog
        <option value="guinness">Guinness
        <option value="stuttgarter">Stuttgarter Schwabenbräu
        </select>
    <input type="submit">
</form>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     No PHP 3, os arrays variáveis de formulários eram limitados
     a uma dimensão. No PHP 4, essa restrição não existe mais.
    </para>

    <sect3 id="language.variables.external.form.submit">
     <title>Nomes de variáveis SUBMIT IMAGE</title>

     <simpara>
      Quando submetendo um formulário, é possível de se utilizar imagens ao invés
      do botão de submit padrão com uma tag do tipo:</simpara>

     <informalexample>
      <programlisting role="php">
<![CDATA[
<input type="image" src="image.gif" name="sub">
]]>
      </programlisting>
     </informalexample>

     <simpara>
      Quando o usuário clica em algum lugar da imagem, o formulário
      que o acompanha é transmitido para o servidor com duas variáveis
      adicionais, sub_x e sub_y. Eles contém a coordenadas do
      clique do usuário na imagem. Os mais experientes percebem que os
      atuais nomes dessas variáveis enviados pelo browser contém um ponto
      ao invés de um sublinhado, mas o PHP converte o ponto para um
      sublinhado automaticamente.
     </simpara>
    </sect3>

   </sect2>

   <sect2 id="language.variables.external.cookies">
    <title>Cookies HTTP</title>

    <simpara>
     O PHP suporta transparentemente cookies HTTP como os definidos pela <ulink
     url="&spec.cookies;">especificação da Netscape</ulink>. Cookies são um
     mecanismo de armazenamento de dados no browser cliente e permite
     o rastreamento ou identificação do retorno de usuários. Você pode criar cookies com
     a função <function>setcookie</function>. Cookies são parte do
     header HTTP, então, a função <function>setcookie</function> precisa ser chamada antes
     de qualquer saída ser enviada ao browser. Esta é a mesma restrição
     da função <function>header</function>. Quaisquer cookies
     enviados para você do cliente será automaticamente transformada em
     variáveis PHP assim como os dados postados via GET ou POST.</simpara>

    <simpara>
     Se você precisa armazenar múltiplos valores em um único cookies, basta
     apenas acrescentar <emphasis>[]</emphasis> ao nome do cookie. Por
     exemplo:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
setcookie("MeuCookie[]", "Testando", time()+3600);
]]>
     </programlisting>
    </informalexample>

    <simpara>
     Note que um cookie substituirá um anterior com o mesmo
     nome em seu browser mesmo se o nome ou o caminho for diferente. Então,
     para uma aplicação de carrinho de compras em que você quer ter um contador
     e repassá-lo:
    </simpara>

    <example>
     <title>Exemplo SetCookie</title>
     <programlisting role="php">
<![CDATA[
$Count++;
setcookie("Count", $Count, time()+3600);
setcookie("Cart[$Count]", $item, time()+3600);
]]>
     </programlisting>
    </example>

   </sect2>

   <sect2 id="language.variables.external.environment">
    <title>Variáveis ambiente</title>

    <para>
     O PHP automaticamente torna as variáveis de ambiente disponíveis como variáveis
     PHP normais.

     <informalexample>
      <programlisting role="php">
<![CDATA[
echo $HOME;  /* Exibe a variável ambiente HOME, se existente. */
]]>
      </programlisting>
     </informalexample>
    </para>

    <para>
     Desde que as informações oriundas dos mecanismos GET, POST ou Cookie
     são automaticamente criadas como variáveis PHP, as vezes é melhor
     fazer a leitura direto do ambiente de execução para ter certeza que
     a esta obtendo a versão correta. A
     função <function>getenv</function> pode ser utilizada para isso. Você
     também pode criar uma variável de ambiente com a
     função <function>putenv</function>.
    </para>
   </sect2>

   <sect2 id="language.variables.external.dot-in-names">
    <title>Pontos em nomes de variáveis postadas</title>

    <para>
     Normalmente o PHP não altera o nome de variáveis quando elas
     são passadas para o script. Entretanto, é necessário notar que o
     ponto (ponto final) não é um caracter válido no nomes de
     variáveis do PHP. Para ilustrar, veja o seguinte exemplo:
     <programlisting role="php">
<![CDATA[
$varname.ext;  /* nome de variável inválido */
]]>
     </programlisting>
     Dessa forma, o interpretador entende isso como uma variável nomeada
     <varname>$varname</varname>, seguida do operador de concatenação
     de strings, seguida de um identificador (uma string não delimitada que
     não bate com nenhuma palavra chave ou reservada) 'ext'. Obviamente,
     isso não tem os resultados pretendidos.
    </para>

    <para>
     Nessa situação, é importante saber que o PHP
     automaticamente substituirá qualquer ponto nos nomes de variáveis recebidas com
     sublinhados.
    </para>

   </sect2>

   <sect2 id="language.variables.determining-type-of">
    <title>Determinando o tipo das variáveis</title>

    <para>
     Porque o PHP determina os tipos de variáveis e faz conversões
     (geralmente) quando necessárias, nem sempre é óbvio o tipo de uma variável
     tem em todos os momentos. O PHP incluí várias funções
     que permitem determinar qual o tipo de uma variável. Elas são
     <function>gettype</function>, <function>is_array</function>,
     <function>is_float</function>, <function>is_int</function>,
     <function>is_object</function>, e
     <function>is_string</function>.
    </para>
   </sect2>

  </sect1>
     
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
