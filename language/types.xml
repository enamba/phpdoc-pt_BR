 <chapter id="language.types">
  <title>Tipos</title>

  <para>
   O PHP suporta os seguintes tipos:
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">matriz</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.float">números de ponto flutuante
      </link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.integer">inteiro</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objeto</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.string">string</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <simpara>
   O tipo da variável geralmente não é setado pelo programador; em vez disso, 
   é decidido em tempo de execução pelo PHP, dependendo do contexto no qual a 
   variável é usada.
  </simpara>
  <simpara>
   Se você gostaria de forçar uma variável a ser convertida para um certo tipo,
   você pode <link linkend="language.types.typecasting">moldar</link> a variável 
   ou usar a função <function>settype</function> nela.
  </simpara>
  <simpara>
   Note que uma variável pode se comportar de maneiras diferentes em certas 
   situações, dependendo de qual tipo ela é no momento. Para mais informações, 
   veja a seção <link linkend="language.types.type-juggling">Manipulação de tipos</link>.
  </simpara>

  <sect1 id="language.types.integer">
   <title>Inteiros</title>
   <para>
    Inteiros podem ser especificados usando-se qualquer uma das seguintes sintaxes:
    <informalexample>
     <programlisting role="php">
$a = 1234; # número decimal 
$a = -123; # um número negativo
$a = 0123; # número octal (equivalente a 83 decimal)
$a = 0x12; # número hexadecimal (equivalente a 18 decimal)
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.types.float">
   <title>Números de ponto flutuante</title>
   <para>
    Números de ponto flutuante ("doubles") podem ser especificados usando-se qualquer
    uma das seguintes sintaxes: 
    <informalexample>
     <programlisting role="php"> 
$a = 1.234; $a = 1.2e3;
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.types.string">
   <title>Strings</title>
   <para>
    Strings podem ser especificadas usando-se um dos dois conjuntos de delimitadores.
   </para>
   <para>
    Se a string está englobada entre aspas ("), as variáveis dentro da string serão
    expandidas (sujeitas a algumas limitações de análise). Como em C e em Perl, a 
    barra invertida ("\") pode ser usada para especificar caracteres especiais:
    <table>
     <title>Caracteres de escape</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>sequence</entry>
        <entry>meaning</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>nova linha</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>retorno de carro</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>tabulação horizontal</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>barra invertida</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>cifrão</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>aspas</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
         a sequência de caracteres que casa com a expressão regular é um
         caractere na notação octal 
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
         a sequência de caracteres que casa com a expressão regular é um
         caractere na notação hexadecimal 
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table></para>
   <para>
    Você pode escapar qualquer outro caractere, mas um alerta será emitido
    no nível mais alto de alertas.
   </para>
   <para>
    A segunda maneira de delimitar uma string usa o apóstrofe ("'"). Quando uma 
    string é englobada por apóstrofes, os únicos escapes que serão entendidos são
    "\\" e "\'". Isto é por conveniência, de forma que você tenha apóstrofes e 
    barras invertidas em uma string com apóstrofes. As variáveis 
    <emphasis>não</emphasis> serão expandidas dentro de uma string com apóstrofes.
   </para>
   <para>
    Outra maneira de delimitar strings é pelo uso da sintaxe 'here doc' 
    ("&lt;&lt;&lt;"). Alguém deve fornecer um identificador depois de
    <literal>&lt;&lt;&lt;</literal>, depois a string, e então o mesmo
    identificador para fechar a citação. O identificador de fechamento
    <emphasis>precisa</emphasis> começar na primeira coluna da linha.
    <example> 
     <title>Exemplo de citação de string 'here doc'</title>
     <programlisting>
$str = &lt;&lt;&lt;EOD
Exemplo de string
dividida em múltiplas linhas 
usando a sintaxe 'heredoc'.
EOD;
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Suporte a 'here doc' foi acrescentado no PHP 4.
    </para>
   </note>
   <para>
    Strings podem ser concatenadas usando-se o operador '.' (ponto). Note
    que o operador '+' (adição) não funcionará para isso. Por favor veja
    <link linkend="language.operators.string">Operadores de string
    </link> para mais informações.
   </para>
   <para>
    Caracteres dentro de strings podem ser acessados pelo tratamento da string 
    como uma matriz de caracteres indexadas numericamente, usando a sintaxe
    no estilo C. Veja alguns exemplos abaixo.
   </para>
   <para>
    <example>
     <title>Alguns exemplos de string</title>
     <programlisting role="php">
&lt;?php
/* Atribuindo uma string. */
$str = "Isto é uma string";

/* Acrescentando a ela. */
$str = $str . " com mais um pouco de texto";

/* Outra maneira de acrescentar, inclui uma nova linha com escape. */
$str .= " e uma nova linha no fim.\n";

/* Esta string terminará sendo '&lt;p&gt;Número: 9&lt;/p&gt;' */
$num = 9;
$str = "&lt;p&gt;Número: $num&lt;/p&gt;";

/* Esta será '&lt;p&gt;Número: $num&lt;/p&gt;' */
$num = 9;
$str = '&lt;p&gt;Number: $num&lt;/p&gt;';

/* Obtém o primeiro caractere da string  */
$str = 'Isto é um teste.';
$first = $str[0];

/* Obtém o último caractere de uma string. */
$str = 'Isto ainda é um teste.';
$last = $str[strlen($str)-1];
?&gt;	  
     </programlisting>
    </example>
   </para>

   <sect2 id="language.types.string.conversion">
    <title>Conversão de String</title>

    <simpara>
     Quando uma string é avaliada como um valor numérico, o valor resultante
     e o tipo são determinados como se segue.
    </simpara>
    <simpara>
     A string será avaliada como um 'double' se contiver qualquer um dos caracteres
     '.', 'e', ou 'E'. Caso contrário, será avaliada como um inteiro.
    </simpara>
    <para>
     O valor é dado pela porção inicial da string. Se a string começa com dados 
     numéricos válidos, estes serão o valor usado. Caso contrário, o valor será 0
     (zero). Dados numéricos válidos são um sinal opcional, seguido por um ou mais
     dígitos (opcionalmente contendo um ponto decimal), seguido por um expoente 
     opcional. O expoente é um 'e' ou 'E' seguido por um ou mais dígitos.
    </para>
    <simpara>
     Quando a primeira expressão é uma string, o tipo de variável dependerá da 
     segunda expressão.
    </simpara>
    <informalexample>
     <programlisting role="php">
$foo = 1 + "10.5";              // $foo é 'double' (11.5)
$foo = 1 + "-1.3e3";            // $foo é 'double' (-1299)
$foo = 1 + "bob-1.3e3";         // $foo é inteiro (1)
$foo = 1 + "bob3";              // $foo é inteiro (1)
$foo = 1 + "10 porquinhos";     // $foo é inteiro (11)
$foo = 1 + "10 porquinhos";     // $foo é inteiro (11)
$foo = "10.0 porcos " + 1;      // $foo é inteiro (11)
$foo = "10.0 porcos " + 1.0;    // $foo é 'double' (11)     
     </programlisting>
    </informalexample>
    <simpara>
     Para mais informações sobre esta conversão, veja a página de manual de strtod(3).
    </simpara>
    <para>
     Se você gostaria de testar qualquer um dos exemplos desta seção, você pode cortar
     e colar os exemplos e inserir a seguinte linha para ver, por você mesmo, o que 
     está acontecendo:
     <informalexample>
      <programlisting role="php">
echo "o tipo de \$foo==$foo; é " . gettype ($foo) . "&lt;br&gt;\n";
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.array">
   <title>Matrizes</title>

   <para>
    Matrizes agem atualmente como tabelas de 'hashing' (matrizes associativas) e matrizes
    indexadas (vetores).
   </para>

   <sect2 id="language.types.array.single-dim">
    <title>Matrizes de Uma Dimensão</title>

    <para>
     O PHP suporta matrizes escalares e associativas. De fato, não há diferença entre as duas.
     Você pode criar uma matriz usando as funções
     <function>list</function> ou <function>array</function>, ou você pode setar cada valor dos
     elementos da matriz explicitamente.
     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Você também pode criar uma matriz simplesmente acrescentando valores à matriz.
     Quando você atribui um valor a uma variável de matriz usando colchetes vazios,
     o valor será acrescentado ao final da matriz.
     <informalexample>
      <programlisting role="php"> 
$a[] = "olá"; // $a[2] == "olá"
$a[] = "mundo"; // $a[3] == "mundo" 
      </programlisting>
     </informalexample>
    </para>
    <para>
     As matrizes podem ser ordenadas usando-se as funções <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, e
     <function>uksort</function>, dependendo do tipo de ordenação que você quer.
    </para>
    <para>
     Você pode contar o número de itens em uma matriz usando a função
     <function>count</function>.
    </para>
    <para>
     Você pode atravessar uma matriz usando as funções <function>next</function> e
     <function>prev</function>. Uma outra maneira comum de atravessar uma matriz é com
     o uso da função <function>each</function>.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Matrizes Multi-Dimensionais</title>

    <para>
     Matrizes multi-dimensionais são bem simples atualmente. Para cada dimensão da matriz, 
     você acrescenta outro valor [chave] no final:
     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # exemplos de uma dimensão
$a["foo"]  = $f;   

$a[1][0]     = $f;             # duas dimensões
$a["foo"][2] = $f;             # (você pode misturar índices numéricos e associativos)
$a[3]["bar"] = $f;             # (você pode misturar índices numéricos e associativos)

$a["foo"][4]["bar"][0] = $f;   # quatro dimensões!
      </programlisting>
     </informalexample>
    </para>
    <para>
     Em PHP3 não é possível referenciar matrizes multidimensionais diretamente dentro de 
     strings. Por exemplo, o que vem a seguir não terá o resultado desejado:
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "Isto não vai funcionar: $a[3][bar]";
      </programlisting>
     </informalexample>
     Em PHP3, o impresso acima será <computeroutput>Isto não vai funcionar:
     Array[bar]</computeroutput>. O operador de concatenação de string, porém, pode ser 
     usado para sobrepôr isto:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Isto não vai funcionar: " . $a[3][bar];
      </programlisting>
     </informalexample>
    </para>
    <para>
     Em PHP4, porém, o problema todo pode ser acobertado englobando a referência da 
     matriz (dentro da string) entre chaves:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Isto vai funcionar: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>
    <para>
     Você pode "preencher" matrizes multidimensionais de muitas formas, mas a mais fácil de
     entender é como usar o comando <function>array</function> para matrizes associativas. 
     Estes dois trechos de código preenchem a matriz unidimensional da mesma forma:
     <informalexample>
      <programlisting role="php"> 
# Exemplo 1:

$a["cor"]	= "vermelho";
$a["sabor"]	= "doce";
$a["forma"]	= "redondo";
$a["nome"]	= "maçã";
$a[3]		= 4;

# Exemplo 2:
$a = array(
     "cor" => "vermelho",
     "sabor" => "doce",
     "forma" => "redondo",
     "nome"  => "maçã",
     3       => 4
);
      </programlisting>
     </informalexample>
    </para>
    <para>
     A função <function>array</function> pode ser aninhada para matrizes multidimensionais:
     <informalexample>
      <programlisting role="php"> 
&lt;?
$a = array(
     "maçã"  => array(
          "cor"  => "vermelho",
          "sabor"  => "doce",
          "forma"  => "redondo"
     ),
     "laranja"  => array(
          "cor"  => "laranja",
          "sabor"  => "azedo",
          "forma"  => "redondo"
     ),
     "banana"  => array(
          "cor"  => "amarelo",
          "sabor"  => "pastoso",
          "forma"  => "cilíndrico"
     )
);

echo $a["maçã"]["sabor"];    # imprimirá "doce"
?>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objetos</title>

   <sect2 id="language.types.object.init">
    <title>Inicialização de Objeto</title>

    <para>
     Para inicializar um objeto, você usa o comando <literal>new</literal> para 
     instanciar o objeto para uma variável.

     <informalexample>
      <programlisting role="php">
&lt;?php
class foo {
    function do_foo() { 
        echo "Fazendo foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Para uma discussão completa, por favor leia a seção <link
     linkend="language.oop">Classes e Objetos</link>.
    </simpara>

   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Type Juggling</title>

   <simpara>
    O PHP não requer (ou suporta) a definição explícita de tipo na declaração
    da variável; um tipo de variável é determinado pelo contexto na qual a variável
    é usada. Quer dizer, se você atribui um valor de string a uma variável
    <parameter>var</parameter>, <parameter>var</parameter> se torna uma string. Se você
    então atribui um valor inteiro a <parameter>var</parameter>, ela se torna inteira.
   </simpara>
   <para>
    Um exemplo de conversão automática de tipo no PHP é o operador de adição '+'. Se 
    qualquer um dos operandos é um 'double', então todos os operandos são avaliados como
    'doubles', e o resultado será um 'double'. Caso contrário, os operandos serão 
    interpretados como inteiros, e o resultado também será um inteiro. Note que isto NÃO
    muda os tipos dos próprios operandos; a única mudança é em como os operandos são
    avaliados.
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo é string (ASCII 48)
$foo++;      // $foo é a string "1" (ASCII 49)
$foo += 1;   // $foo agora é um inteiro (2)
$foo = $foo + 1.3;  // $foo agora é um double (3.3)
$foo = 5 + "10 Porquinhos"; // $foo é inteiro (15)
$foo = 5 + "10 Porquinhos";     // $foo é inteiro (15)
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Se os últimos dois exemplos acima parecem incomuns, veja <link
    linkend="language.types.string.conversion">Conversão de Strings</link>.
   </simpara>
   <simpara>
    Se você deseja forçar uma variável a ser avaliada como um certo tipo, veja a seção
    sobre<link linkend="language.types.typecasting">Moldagem de tipo</link>. Se você deseja
    mudar o tipo de uma variável, veja <function>settype</function>.
   </simpara>
   <para>
    Se você gostaria de testar qualquer um dos exemplos desta seção, você pode cortar e colar
    os exemplos e inserir a seguinte linha para ver, por você mesmo, o que está acontecendo:
    <informalexample>
     <programlisting role="php">
echo "o tipo de \$foo==$foo; é " . gettype ($foo) . "&lt;br&gt;\n";
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     O comportamento de uma conversão automática para matriz não é definida no momento.
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a é um inteiro
$a[0] = "f";  // $a se torna uma matriz, com $a[0] mantendo "f"
      </programlisting>
     </informalexample>
    </para>
    <para>
     Enquanto o exemplo acima pode parecer que vai claramente resultar em $a se tornar uma 
     matriz, do qual o primeiro elemento é 'f', considere isto:
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a é uma string
$a[0] = "f";  // E as compensações de string? O que acontece?
      </programlisting>
     </informalexample>
    </para>
    <para>
     Como o PHP suporta indexação para strings através de compensações usando a mesma sintaxe
     que a indexação de matrizes, o exemplo acima conduz a um problema: $a deveria se tornar
     uma matriz com seu primeiro elemento sendo
     "f", ou "f" deveria se tornar o primeiro caractere da string $a?
    </para>
    <para>
     Por esta razão, como no PHP 3.0.12 e no PHP 4.0b3-RC4, o resultado desta conversão
     automática é considerado indefinido. Correções estão, portanto, sendo discutidas.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Moldagem de tipo</title>

    <para>
     Moldagem de tipo no PHP funciona de forma semelhante ao C: o nome do tipo desejado é escrito
     entre parênteses antes da variável que se quer moldar.
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo é um inteiro
$bar = (double) $foo;   // $bar é um double
      </programlisting>
     </informalexample>
    </para>
    <para>
     As moldagens permitidas são:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - molda para inteiro</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - molda para 'double'</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - molda para string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - molda para matriz</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - molda para objeto</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Note que tabulações e espaços são permitidos dentro dos parênteses, assim
     os exemplos a seguir são funcionalmente equivalentes:
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Pode não ser exatamente óbvio o que acontece quando ocorre a moldagem
     entre certos tipos. Por exemplo, o seguinte deve ser notado.
    </para>
    <para>
     Quando se molda uma variável escalar ou string para uma matriz, 
     a variável se tornará o primeiro elemento da matriz:
     <informalexample>
      <programlisting role="php">
$var = 'tchau';
$arr = (array) $var;
echo $arr[0];  // imprime 'tchau'  
      </programlisting>
     </informalexample>
    </para>
    <para>
     Quando se molda uma variável escalar ou string para um objeto, a 
     variável se tornará um atributo do objeto; o nome do atributo será 'scalar':
     <informalexample>
      <programlisting role="php">
$var = 'tchau';
$obj = (object) $var;
echo $obj-&gt;scalar;  // imprime 'ciao'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1 
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
