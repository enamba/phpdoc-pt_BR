<?xml version="1.0" encoding="iso-8859-1"?>
  <chapter id="language.operators">
   <title>Operadores</title>
   <simpara>
   </simpara>

   <sect1 id="language.operators.arithmetic">
    <title>Operadores Aritméticos</title>
    <simpara>
     Lembra-se da aritmética básica da escola? Estes operadores funcionam 
     exatamente como aqueles.
    </simpara>

    <table>
     <title>Operadores Aritméticos</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemplo</entry>
        <entry>nome</entry>
        <entry>resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a + $b</entry>
        <entry>Adição</entry>
        <entry>Soma de $a e $b.</entry>
       </row>
       <row>
        <entry>$a - $b</entry>
        <entry>Subtração</entry>
        <entry>Diferença entre $a e $b.</entry>
       </row>
       <row>
        <entry>$a * $b</entry>
        <entry>Multiplicação</entry>
        <entry>Produto de $a e $b.</entry>
       </row>
       <row>
        <entry>$a / $b</entry>
        <entry>Divisão</entry>
        <entry>Quociente de $a por $b.</entry>
       </row>
       <row>
        <entry>$a % $b</entry>
        <entry>Módulo</entry>
        <entry>Resto de $a dividido por $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!-- Isto parece estar impreciso. Divisão sempre retorna ponto flutuante.
    <simpara>
     O operador de divisão ("/") retorna um valor inteiro (o resultado de uma 
     divisão de inteiros) se os dois operandos são inteiros (ou strings que 
     foram convertidos para inteiros). Se o operando é um valor de ponto
     flutuante, é realizada a divisão de ponto flutuante.
    </simpara>
--></sect1>

   <sect1 id="language.operators.assignment">
    <title>Operadores de Atribuição</title>
    <simpara>
     O operador básico de atribuição é "=". A sua primeira inclinação deve ser 
     a de pensar nisto como "é igual". Não. Isto quer dizer, na verdade, que o 
     operando da esquerda recebe o valor da expressão da direita (ou seja, 
     "é setado para").
    </simpara>
    <para>
     O valor de uma expressão de atribuição é o valor atribuído. Ou seja, o valor
     de "$a = 3" é 3. Isto permite que você faça alguns truques:
     <informalexample><programlisting>
$a = ($b = 4) + 5; // $a é igual a 9 agora, e $b foi setado para 4.
</programlisting></informalexample>
    </para>
    <para>
     Além do operador básico de atribuição, há "operadores combinados" para todos
     os operadores binários, aritméticos e de string que permitem a você usar um
     valor em uma expressão e então setar seu valor para o resultado daquela
     expressão. Por exemplo: <informalexample><programlisting>
$a = 3;
$a += 5; // seta $a para 8, como se disséssemos: $a = $a + 5;
$b = "Olá ";
$b .= "Aí!"; // seta $b para "Olá Aí!", como $b = $b . "Aí!";
</programlisting></informalexample>
    </para>

   <para>
	Note que a atribuição copia a variável original para a nova (atribuição por
	valor), assim a mudança de uma não afeta a outra. Isto também pode ser 
	relevância se você precisa copiar algo como uma grande matriz dentro de um
	'loop' apertado. O PHP4 suporta atribuições por referência, usando a sintaxe
	<computeroutput>$var = &amp;$othervar;</computeroutput>, mas isto não é 
	possível no PHP3. 'Atribuição por referência' significa que ambas as variáveis 
	acabam apontando para os mesmos dados, e nada é copiado para lugar nenhum.
   </para>

  </sect1>

   <sect1 id="language.operators.bitwise">
    <title>Operador Bit-a-bit</title>
    <simpara>
     Operadores bit-a-bit permitem que você acione ou desligue bits específicos dentro  
     de um inteiro.
    </simpara>

    <table>
     <title>Operadores Bit-a-bit</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemplo</entry>
        <entry>nome</entry>
        <entry>resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a &amp; $b</entry>
        <entry>E</entry>
        <entry>Os bits que estão setados tanto em $a quanto em $b são setados.</entry>
       </row>
       <row>
        <entry>$a | $b</entry>
        <entry>OU</entry>
        <entry>Os bits que estão setados em $a ou em $b são setados.</entry>
       </row>
       <row>
        <entry>$a ^ $b</entry>
        <entry>XOR</entry>
        <entry>Os bits que estão setados em $a ou em $b, mas não em ambos, são setados.</entry>
       </row>
       <row>
        <entry>~ $a</entry>
        <entry>NÃO</entry>
        <entry>Os bits que estão setados em $a não são setados, e vice-versa.</entry>
       </row>
       <row>
        <entry>$a &lt;&lt; $b</entry>
        <entry>Deslocamento à esquerda</entry>
        <entry>Desloca os bits de $a $b passos para a esquerda (cada passo significa "multiplica por dois")</entry>
       </row>
       <row>
        <entry>$a &gt;&gt; $b</entry>
        <entry>Deslocamento à direita</entry>
        <entry>Desloca os bits de $a $b passos para a direita (cada passo significa "divide por dois")</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>



   <sect1 id="language.operators.comparison">
    <title>Operadores de Comparação</title>
    <simpara>
     Operadores de comparação, como os seus nomes implicam, permitem que você
     compare dois valores.
    </simpara>

    <table>
     <title>Operadores de comparação</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemplo</entry>
        <entry>nome</entry>
        <entry>resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a == $b</entry>
        <entry>Igual</entry>
        <entry>Verdadeiro se $a é igual a $b.</entry>
       </row>
       <row>
        <entry>$a === $b</entry>
        <entry>Idêntico</entry>
        <entry>Verdadeiro se $a é igual a $b, e eles são do mesmo tipo.
		(somente para PHP4)</entry>
       </row>
       <row>
        <entry>$a != $b</entry>
        <entry>Diferente</entry>
        <entry>Verdadeiro se $a não é igual a $b.</entry>
       </row>
       <row>
        <entry>$a &lt; $b</entry>
        <entry>Menor que</entry>
        <entry>Verdadeiro se $a é estritamente menor que $b.</entry>
       </row>
       <row>
        <entry>$a &gt; $b</entry>
        <entry>Maior que </entry>
        <entry>Verdadeiro se $a é estritamente maior que $b.</entry>
       </row>
       <row>
        <entry>$a &lt;= $b</entry>
        <entry>Menor ou igual </entry>
        <entry>Verdadeiro se $a é menor ou igual a $b.</entry>
       </row>
       <row>
        <entry>$a &gt;= $b</entry>
        <entry>Maior ou igual</entry>
        <entry>Verdadeiro se $a é maior ou igual a $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
     Outro operador condicional é o operador "?:" (ou trinário), que opera
     como em C e muitas outras linguagens.
	
	<informalexample>
	 <programlisting>
(expr1) ? (expr2) : (expr3);
	 </programlisting>
	</informalexample> 

	Esta expressão é avaliada como <replaceable>expr2</replaceable> se
	<replaceable>expr1</replaceable> é avaliada como verdadeira, e
	<replaceable>expr3</replaceable> se
	<replaceable>expr1</replaceable> é avaliada como falsa.
   </para>
  </sect1>


  <sect1 id="language.operators.errorcontrol">
   <title>Operadores de controle de erro</title>
   
   <simpara>
    O PHP suporta um operador de controle de erro: o sinal 'em' (@). Quando
    ele precede uma expressão em PHP, qualquer mensagem de erro que possa ser 
    gerada por aquela expressão será ignorada. 
   </simpara>

   <simpara>
    Se a implementação <link linkend="ini.track-errors">track_errors</link>
    estiver habilitada, qualquer mensagem de erro gerada pela expressão será
    gravada na variável global $php_errormsg. Esta variável será sobreescrita
    em cada erro, assim verifique-a constantemente se você quiser usá-la.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
/* Erro SQL intencional (aspas extras): */
$res = @mysql_query( "select name, code from 'namelist" ) or
   die( "Falha na Query: erro foi '$php_errormsg'" );
?&gt;
     </programlisting>
    </informalexample>

   </para>

   <simpara>
    Veja também <function>error_reporting</function>.
   </simpara>

  </sect1>


  <sect1 id="language.operators.execution">
   <title>Operadores de Execução</title>
   
   <para>
	O PHP suporta um operador de execução: acentos graves (``). Note que não são
	apóstrofes! O PHP tentará executar o conteúdo dos acentos graves como um 
	comando do shell; a saída será retornada (isto é, ela não será simplesmente
	descarregada para a saída; ela pode ser atribuída a uma variável).

	<informalexample>
	 <programlisting role="php">
$output = `ls -al`;
echo "&lt;pre&gt;$output&lt;/pre&gt;";
	 </programlisting>
	</informalexample>

   </para>

   <para>
	Veja também <function>system</function>,
	<function>passthru</function>, <function>exec</function>,
	<function>popen</function>, e
	<function>escapeshellcmd</function>.
   </para>

  </sect1>

  
  <sect1 id="language.operators.increment">
   <title>Operadores de Incremento/Decremento</title>

   <para>
	O PHP suporta operadores de pré e pós-incremento e decremento
	no estilo C.
   </para>

    <table>
     <title>Operadores de Incremento/Decremento</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemplo</entry>
        <entry>nome</entry>
        <entry>efeito</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>++$a</entry>
        <entry>Pré-incremento</entry>
        <entry>Incrementa $a de um, e então retorna $a.</entry>
       </row>
       <row>
        <entry>$a++</entry>
        <entry>Pós-incremento</entry>
        <entry>Retorna $a, e então incrementa $a de um.</entry>
       </row>
       <row>
        <entry>--$a</entry>
        <entry>Pré-decremento</entry>
        <entry>Decrementa $a de um, e então retorna $a.</entry>
       </row>
       <row>
        <entry>$a--</entry>
        <entry>Pós-decremento</entry>
        <entry>Retorna $a, e então decrementa $a de um.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
	Aqui está um script de exemplo simples:
	<informalexample>
	 <programlisting>
&lt;?php
echo "&lt;h3&gt;Pós-incremento&lt;/h3&gt;";
$a = 5;
echo "Deve ser 5: " . $a++ . "&lt;br&gt;\n";
echo "Deve ser 6: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Pré-incremento&lt;/h3&gt;";
$a = 5;
echo "Deve ser 6: " . ++$a . "&lt;br&gt;\n";
echo "Deve ser 6: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Pós-decremento&lt;/h3&gt;";
$a = 5;
echo "Deve ser 5: " . $a-- . "&lt;br&gt;\n";
echo "Deve ser 4: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Pré-decremento&lt;/h3&gt;";
$a = 5;
echo "Deve ser 4: " . --$a . "&lt;br&gt;\n";
echo "Deve ser 4: " . $a . "&lt;br&gt;\n";
?&gt;	  
	 </programlisting>
	</informalexample>
   </para>

  </sect1>


  <sect1 id="language.operators.logical">
    <title>Operadores Lógicos</title>

    <table>
     <title>Operadores Lógicos</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemplo</entry>
        <entry>nome</entry>
        <entry>resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a and $b</entry>
        <entry>E</entry>
        <entry>Verdadeiro se tanto $a quanto $b são verdadeiros.</entry>
       </row>
       <row>
        <entry>$a or $b</entry>
        <entry>OU</entry>
        <entry>Verdadeiro se $a ou $b são verdadeiros.</entry>
       </row>
       <row>
        <entry>$a xor $b</entry>
        <entry>XOR</entry>
        <entry>Verdadeiro se $a ou $b são verdadeiros, mas não ambos.</entry>
       </row>
       <row>
        <entry>! $a</entry>
        <entry>NÃO</entry>
        <entry>Verdadeiro se $a não é verdadeiro.</entry>
       </row>
       <row>
        <entry>$a &amp;&amp; $b</entry>
        <entry>E</entry>
        <entry>Verdadeiro se tanto $a quanto $b são verdadeiros.</entry>
       </row>
       <row>
        <entry>$a || $b</entry>
        <entry>OU</entry>
        <entry>Verdadeiro se $a ou $b são verdadeiros.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <simpara>
	A razão para as duas variantes dos operandos "and" e "or"
	é que eles operam com precedências diferentes. (Veja
	<link linkend="language.operators.precedence">Precedência de Operadores
	</link>.)
   </simpara>
  </sect1>

   <sect1 id="language.operators.precedence">
    <title>Precedência de Operadores</title>
    <para>
     A precedência de um operador especifica quão "intimamente" ele liga duas
     expressões. Por exemplo, na expressão <literal>1 + 5 * 3</literal>, a
     resposta é 16 e não 18 porque o operador de multiplicação ("*") tem uma 
     precedência mais alta que o operador de adição ("+").</para>
    <para>
     A tabela a seguir lista a precedência de operadores com os operadores 
     de menor precedência listados primeiro.

    <table>
     <title>Precedência de Operadores</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associatividade</entry>
        <entry>Operadores</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>esquerda</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>= += -= *= /= .= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;=</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>== != ===</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table></para></sect1>

  <sect1 id="language.operators.string">
   <title>Operadores de String</title>
   <simpara>
	Há dois operadores de string. O primeiro é o operador de concatenação
	('.'), que retorna a concatenação dos seus argumentos direito e esquerdo.
	O segundo é o operador de atribuição de concatenação ('.='). Por favor 
	leia <link linkend="language.operators.assignment">Operadores de Atribuição
	</link> para mais informações.
   </simpara>
   <para>
	<informalexample>
	 <programlisting>
$a = "Olá ";
$b = $a . "mundo!"; // agora $b contém "Olá mundo!"

$a = "Olá ";
$a .= "mundo!"; // agora $a contém "Olá mundo!"
     </programlisting>
	</informalexample>
   </para>
  </sect1>


  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
