 <chapter id="functions">
  <title>Funções</title>

  <sect1 id="functions.user-defined">
   <title>Funções definidas pelo usuário</title>
 
   <para>
    Uma função pode ser definida usando-se a sintaxe como a seguinte:
 
    <informalexample>
     <programlisting role="php">
function foo ($arg_1, $arg_2, ..., $arg_n) {
    echo "Função-exemplo.\n";
    return $retval;
}
     </programlisting>
    </informalexample>
   </para>
     
   <simpara>
    Qualquer código PHP válido aparece dentro de uma função, mesmo outras funções
    e definições de <link linkend="keyword.class">classes</link>.
   </simpara>
   <simpara>
    No PHP3, as funções precisam ser definidas antes de serem referenciadas. Esse
    requisito não existe no PHP4.
   </simpara>
   <simpara>
    O PHP não suporta sobrecarga de funções, e também não é possível cancelar ou
    alterar a definição de funções previamente declaradas.
   </simpara>
   <simpara>
    O PHP3 não suporta número variável de argumentos para funções, apesar de os 
    argumentos padrões serem suportados (veja <link
    linkend="functions.arguments.default">Valores padrão de argumentos
    </link> para mais informações). O PHP4 suporta ambos: veja <link
    linkend="functions.variable-arg-list">Listas de argumentos com comprimento
    variável</link> e as referências de função de
    <function>func_num_args</function>,
    <function>func_get_arg</function>, e
    <function>func_get_args</function> para mais informações.
   </simpara>

  </sect1>
 
  <sect1 id="functions.arguments">
   <title>Argumentos de funções</title>
 
   <simpara>
    Informação pode ser passada para funções através da lista de argumentos, que é uma 
    lista de variáveis e/ou constantes delimitados por vírgulas.
   </simpara> 
   <para>
     O PHP suporta a passagem de argumentos por valor (o padrão), <link
     linkend="functions.arguments.by-reference">passagem por referência
     </link>, e <link
     linkend="functions.arguments.default">valores padrão de argumento
     </link>. Listas de argumentos de comprimento variável são suportadas apenas
     no PHP4 e posteriores; veja <link
     linkend="functions.variable-arg-list">Listas de argumentos de comprimento 
     variável</link> e as referências de função de
     <function>func_num_args</function>,
     <function>func_get_arg</function>, e
     <function>func_get_args</function> para mais informações. Um efeito similar
     pode ser atingido no PHP3 pela passagem de uma matriz de argumentos para uma
     função:
 
    <informalexample>
     <programlisting role="php">
function takes_array($input) {
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
     </programlisting>
    </informalexample>
   </para>
 
   <sect2 id="functions.arguments.by-reference">
    <title>Fazendo argumentos serem passados por referência</title>
 
    <simpara>
     Por padrão, argumentos de função são passados por valor (de forma que se
     você mudar o valor do argumento dentro da função, ele não é mudado fora
     da função). Se você deseja permitir que uma função modifique seus argumentos,
     você precisa passá-los por referência.
    </simpara>
    <para>
     Se você quer que um argumento para uma função sempre seja passado por
     referência, você pode preceder o nome do argumento com um "e comercial" (&amp;)
     na definição da função:
 
     <informalexample>
      <programlisting role="php">
function add_some_extra(&amp;$string) {
    $string .= 'e algo mais.';
}
$str = 'Isto é uma string, ';
add_some_extra($str);
echo $str;    // outputs 'Isto é uma string, e algo mais.'
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Se você deseja passar uma variável por referência a uma função que não faz isto por
     padrão, você pode preceder o nome do argumento com um "e comercial" na chamada da
     função:
 
     <informalexample>
      <programlisting role="php">
function foo ($bar) {
    $bar .= ' e algo mais.';
}
$str = 'Isto é uma string, ';
foo ($str);
echo $str;    // outputs 'Isto é uma string, '
foo (&amp;$str);
echo $str;    // outputs 'Isto é uma string, e algo mais.'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
 
   <sect2 id="functions.arguments.default">
    <title>Valores padrão de argumentos</title>
 
    <para>
     Uma função pode definir valores padrão no estilo C++ para argumentos escalares, como
     a seguir:
 
     <informalexample>
      <programlisting role="php">
function makecoffee ($type = "cappucino") {
    return "Fazendo uma xícara de $type.\n";
}
echo makecoffee ();
echo makecoffee ("café expresso");
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     The output from the above snippet is:
 
     <screen>
Fazendo uma xícara de cappucino.
Fazendo uma xícara de café expresso.
     </screen>
    </para>
 
    <simpara>
     O valor padrão precisa ser uma expressão constante, não (por
     exemplo) uma variável ou um membro de classe.
    </simpara>
    <para>
     Note que usando argumentos padrão, qualquer padrão dever estar do lado
     direito de argumentos não-padrão; caso contrário, as coisas não funcionarão
     como esperado. Considere o seguinte trecho de código:
 
     <informalexample>
      <programlisting role="php">
function makeyogurt ($type = "azeda", $flavour) {
    return "Fazendo uma taça de $flavour $type.\n";
}
 
echo makeyogurt ("framboesa");   // não vai funcionar como o esperado
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     A saída do exemplo acima é:
 
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Fazendo uma taça de framboesa.
     </screen>
    </para>
 
    <para>
     Agora, compare o que está acima com este:
 
     <informalexample>
      <programlisting role="php">
function makeyogurt ($flavour, $type = "azeda") {
    return "Fazendo uma taça de $flavour $type.\n";
}
 
echo makeyogurt ("framboesa");   // funciona como o esperado
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     A saída deste exemplo é:
 
     <screen>
Fazendo uma taça de framboesa azeda.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Listas de argumentos de comprimento variável</title>
	
    <simpara>
     O PHP4 tem suporte para listas de argumentos de comprimento variável
     nas funções definidas pelo usuário. Isto é realmente bem fácil, usando 
     as funções <function>func_num_args</function>,
     <function>func_get_arg</function>, e
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Nenhuma sintaxe especial é requerida, e as listas de argumentos ainda 
     podem ser fornecidas explicitamente com as definições de funções e se
     comportarão normalmente.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 id="functions.returning-values">
   <title>Returnando valores</title>
 
   <para>
    Valores são retornados pelo uso de comandos opcionais de retorno. Qualquer
    tipo pode ser retornado, incluindo listas e objetos.
 
    <informalexample>
     <programlisting role="php">
function square ($num) {
    return $num * $num;
}
echo square (4);   // imprime '16'.
     </programlisting>
    </informalexample>
   </para>
      
   <para>
    Você não pode retornar múltiplos valores a partir de uma função, mas 
    resultados similares podem ser obtidos retornando uma lista.
 
    <informalexample>
     <programlisting role="php">
function small_numbers() {
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
     </programlisting>
    </informalexample>
   </para>

  </sect1>
 
  <sect1 id="functions.old-syntax">
   <title><literal>old_function</literal></title>
 
   <simpara>
    O comando <literal>old_function</literal> permite que você declare uma 
    função usando uma sintaxe idêntica ao PHP/FI2 (exceto pelo fato de que
    você precisa substituir 'function' com 'old_function').
   </simpara>
   <simpara>
    Esta é uma implementação obsoleta, e deve ser usada somente pelo
    conversor PHP/FI2->PHP3.
   </simpara>
   <warning>
    <para>
     Funções declaradas como <literal>old_function</literal> não podem ser chamadas
     a partir de código interno do PHP. Entre outras coisas, isso significa que você
     não pode usá-las em funções como
     <function>usort</function>, <function>array_walk</function>, e
     <function>register_shutdown_function</function>. Você pode contornar essa 
     limitação escrevendo um invólucro de função (no formato PHP3 normal) para chamar
     o <literal>old_function</literal>.
    </para>
   </warning>

  </sect1>

  <sect1 id="functions.variable-functions">
   <title>Variable functions</title>

   <para>
    O PHP suporta o conceito de funções variáveis. Isto significa que se um nome de 
    variável tem parênteses juntos como ele, o PHP procurará uma função com o mesmo
    nome, qualquer que seja a avaliação da variável, e tentará executá-la. Entre outras
    coisas, isto pode ser usado para implementar retornos, tabelas de função e 
    assim por diante.
   </para>

   <para>
    <example>
     <title>Exemplo de funções variáveis</title>
     <programlisting role="php">
&lt;?php
function foo() {
    echo "Em foo()&lt;br>\n";
}

function bar( $arg = '' ) {
    echo "Em bar(); argumento era '$arg'.&lt;br>\n";
}

$func = 'foo';
$func();
$func = 'bar';
$func( 'teste' );
?>
     </programlisting>
    </example>
   </para>

  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
