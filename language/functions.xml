<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.40 Maintainer: ae Status: ready -->
 <chapter id="functions">
  <title>Funções</title>

  <sect1 id="functions.user-defined">
   <title>Funções definidas pelo usuário</title>

   <para>
    Uma função pode ser definida usando-se a sintaxe como a seguinte:
   </para>
   <para>
    <example>
     <title>Psuedo-código que de demonstração de uma função</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo ($argumento_1, $argumento_2, ..., $argumento_n)
{
    echo "Exemplo de função.\n";
    return $valor_retornado;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <!--

    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)

    -->

   <simpara>
    Qualquer código PHP válido pode aparecer dentro de uma função, mesmo outras funções
    e definições de <link linkend="keyword.class">classes</link>.

   </simpara>
   <simpara>
    No PHP 3, as funções precisam ser definidas antes de serem referenciadas. Esse
    requisito não existe no PHP 4. <emphasis>Exceto</emphasis> quando
    uma função é definida condicionalmente como mostrada nos dois exemplos
    abaixo:
   </simpara>
   <para>
    Quando uma função é definida condicionalmente como nos dois
    exemplos abaixo, sua definição precusa ser processada <emphasis>antes</emphasis>
    de ser chamada.
   </para>
   <para>
    <example>
     <title>Funções definidas condicionalmente</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Nos nao podemos chamar foo() daqui
   porque ela ainda não existe,
   mas nos podemos chamar bar() */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "Eu não existo até que o programa passe por aqui.\n";
  }
}

/* Agora nos podemos chamar foo()
   porque $makefoo foi avaliado como true */

if ($makefoo) foo();

function bar()
{
  echo "Eu existo imediatamente desde o programa começar.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funções dentro de funções</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Eu não existo até foo() ser chamada.\n";
  }
}

/* Nós não podemos chamar bar() ainda
   porque ela ainda não foi definida. */

foo();

/* Agora nós podemos chamar bar(),
   porque o processamento de foo()
   tornou a primeira acessivel */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    O PHP não suporta sobrecarga de funções, e também não é possível cancelar ou
    alterar a definição de funções previamente declaradas.
   </simpara>
   <note>
    <simpara>
     Nomes de funções são insensíveis ao caso, mas é melhor chamar
     as funções da mesma forma que ela aparecem nas declarações.
    </simpara>
   </note>
   <simpara>
    O PHP3 não suporta número variável de argumentos para funções, apesar de os
    argumentos padrões serem suportados (veja <link
    linkend="functions.arguments.default">Valores padrão de argumentos
    </link> para mais informações). O PHP4 suporta ambos: veja <link
    linkend="functions.variable-arg-list">Número de argumentos
    variável</link> e as referências das funções
    <function>func_num_args</function>,
    <function>func_get_arg</function> e
    <function>func_get_args</function> para mais informações.
   </simpara>

  </sect1>

  <sect1 id="functions.arguments">
   <title>Argumentos de funções</title>

   <simpara>
    Informações podem ser passadas para funções através da lista de argumentos, que é uma
    lista de variáveis e/ou constantes delimitados por vírgulas.
   </simpara>
   <para>
    O PHP suporta a passagem de argumentos por valor (o padrão), <link
    linkend="functions.arguments.by-reference">passagem por
    referência</link> e <link
    linkend="functions.arguments.default">valores padrão de
    argumento</link>. Listas de argumentos de comprimento variável são suportadas apenas
    no PHP4 e posterior; veja <link
    linkend="functions.variable-arg-list">Número de argumentos
    variável</link> e as referências das funções
    <function>func_num_args</function>,
    <function>func_get_arg</function> e
    <function>func_get_args</function> para mais informações. Um
    efeito similar pode ser atingido no PHP 3 pela passagem de um array de
    argumentos para uma função:
   </para>
   <para>
    <example>
     <title>Passando arrays para funções</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 id="functions.arguments.by-reference">
    <title>Fazendo argumentos serem passados por referência</title>

    <simpara>
     Por padrão, argumentos de função são passados por valor (de forma que se
     você mudar o valor do parâmetro dentro da função, ele não é alterado fora
     da função). Se você deseja permitir que uma função modifique seus argumentos,
     você precisa passá-los por
     referência.
    </simpara>
    <para>
     Se você quer que um argumento para uma função sempre seja passado por
     referência, você pode preceder o nome do argumento com um "e comercial" (&amp;)
     na definição da função:
    </para>
    <para>
     <example>
      <title>Passando parâmetros de função por referência</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= ' e alguma coisa mais.';
}
$str = 'Isto é uma string,';
add_some_extra($str);
echo $str;    // imprime 'Isto é uma string, e alguma coisa mais.'
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 id="functions.arguments.default">
    <title>Valores padrão de argumentos</title>

    <para>
     Uma função pode definir valores padrão no estilo C++ para argumentos escalares, como
     a seguir:
    </para>
    <para>
     <example>
      <title>Utilizando parâmtros default em funções</title>
      <programlisting role="php">
<![CDATA[
<?php
function cafeteira ($tipo = "cappuccino")
{
    return "Fazendo uma xícara de café $type.\n";
}
echo cafeteira ();
echo cafeteira ("expresso");
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     A saída do código acima será:
    </para>
    <para>
     <screen>
Fazendo uma xícara de café cappucino.
Fazendo uma xícara de café expresso.
     </screen>
    </para>

    <simpara>
     O valor padrão precisa ser uma expressão constante, não (por
     exemplo) uma variável, um membro de classe ou uma chamada de função.
    </simpara>
    <para>
     Note que usando argumentos padrão, qualquer padrão deve vir após
     os argumentos sem padrão: caso contrário, as coisas não funcionarão
     como esperado. Considere o seguinte trecho de código:
    </para>
    <para>
     <example>
      <title>Uso incorreto de parâmetros de função default</title>
      <programlisting role="php">
<![CDATA[
<?php
function iogurtera ($tipo = "azeda", $sabor)
{
    return "Fazendo uma taça de $tipo $sabor.\n";
}

echo iogurtera ("framboesa");   // não funciona como esperado
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     A saída do exemplo acima é:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to iogurtera() in
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Fazendo uma taça de framboesa.
     </screen>
    </para>
    <para>
     Agora, compare o que está acima com este:
    </para>
    <para>
     <example>
      <title>Uso correto de parâmetros de função default</title>
      <programlisting role="php">
<![CDATA[
<?php
function iogurtera ($sabor, $tipo = "azeda")
{
    return "Fazendo uma taça de $tipo $sabor.\n";
}

echo iogurtera ("framboesa");   // funciona
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     A saída deste exemplo é:
    </para>
    <para>
     <screen>
Fazendo uma taça de framboesa azeda.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Número variável de argumentos</title>

    <simpara>
     O PHP4 tem suporte para um número variável de argumentos
     nas funções definidas pelo usuário. Isto é realmente bem fácil, usando
     as funções <function>func_num_args</function>,
     <function>func_get_arg</function> e
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Nenhuma sintaxe especial é requerida, e a lista de argumentos ainda
     pode ser fornecida explicitamente com as definições de funções e se
     comportarão normalmente.
    </simpara>

   </sect2>

  </sect1>

  <sect1 id="functions.returning-values">
   <title>Retornando valores</title>

   <para>
    Valores podem ser retornados utilizando a instrução opcional return. Qualquer
    tipo pode ser retornado, incluindo arrays e objetos. Isto faz com que
    as função termine sua execução imediatamente e passa o controle de volta para
    a linha de onde ela foi chamada. Veja a documentação da função <function>return</function>
    para maiores informações.
   </para>
   <para>
    <example>
     <title>O uso de <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function quadrado ($num)
{
    return $num * $num;
}
echo quadrado (4);   // imprime '16'.
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Você não pode retornar múltiplos valores a partir de uma função, mas
    resultados similares podem ser devolvidos retornando por uma lista.
   </para>
   <para>
    <example>
     <title>Retornando um array para devolver vários valores</title>
     <programlisting role="php">
<![CDATA[
<?php
function numeros_pequenos()
{
    return array (0, 1, 2);
}
list ($zero, $um, $dois) = numeros_pequenos();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Para retornar uma referência de uma função, você precisa utilizar
    o operador de referência &amp; tanto na declaração da função como
    quando assimilando o valor retornado para a variável.
   </para>
   <para>
    <example>
     <title>Retornando uma referência de uma função</title>
     <programlisting role="php">
<![CDATA[
<?php
function &retorna_referencia()
{
    return $alguma_referencia;
}

$nova_referencia =& retorna_referencia();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Para mais detalhes sobre referências, leia a seção <link
    linkend="language.references">Referências</link>.
   </simpara>
  </sect1>

  <sect1 id="functions.variable-functions">
   <title>Funções variáveis</title>

   <para>
    O PHP suporta o conceito de funções variáveis. Isto significa que se
    um nome de variável tem parênteses no final dela, o PHP procurará
    uma função com o mesmo nome, qualquer que seja a avaliação da variável,
    e tentará executá-la. Entre outras coisas, isto pode
    ser usado para implementar callbacks, tabelas de função e assim por diante.
   </para>
   <para>
    Funções variáveis não funcionam com construtores de linguagem como
    <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> e outras assim. Você precisa antes construir
    uma função interceptadora (wrapper) para utilizar qualquer um desses construtores
    como funções convencionais.
   </para>
   <para>
    <example>
     <title>Exemplo de funções variáveis</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "Chamou foo()<br>\n";
}

function bar($arg = '')
{
    echo "Chamou bar(); com argumento '$arg'.<br>\n";
}

// Essa eh uma funcao wrapper para echo()
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Chama foo()

$func = 'bar';
$func('test');  // Chama bar()

$func = 'echoit';
$func('test');  // Chama echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Você também pode chamar métodos de objetos utilizando o recurso de funções
    variáveis.
    <example>
     <title>Exemplo de chama de método variável</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Var()
    {
        $name = 'Bar';
        $this->$name(); // Isto chama o método Bar()
    }

    function Bar()
    {
        echo "Bar foi chamada!";
    }
}

$foo = new Foo();
$funcname = "Var";
$foo->$funcname();  // Isto chama $foo->Var()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Veja também <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    variáveis variáveis</link> e <function>function_exists</function>.
   </para>
  </sect1>

  <sect1 id="functions.internal">
   <title>Funções internas (built-in)</title>

   <para>
    O PHP padrão vem com várias funções e construtores. Eles podem ser
    funções que dependem de extensões específicas do PHP compiladas, ou de outra forma
    você obterá erros fatais "undefined function". Por exemplo, para usar
    <link linkend="ref.image">funções imagem</link> como a
    <function>imagecreatetruecolor</function>, você precisa que seu PHP seja compilado
    com suporte ao GD. Ou, para utilizar <function>mysql_connect</function> você
    precisará ter seu PHP compilado com  suporte ao <link linkend="ref.mysql">MySQL</link>.
    Há várias funções centrais que são incluídas em cada
    versão do PHP como funções de <link linkend="ref.strings">strings</link> e
    <link linkend="ref.variables">variáveis</link>. Uma chamada a
    <function>phpinfo</function> ou
    <function>get_loaded_extensions</function> mostrará que
    extensões estão carregadas em seu PHP. Note também que várias extensões são
    ativadas por padrão e que o manual do PHP está separado por extensões.
    Veja os capítulos <link linkend="configuration">configuração</link>,
    <link linkend="installation">instalação</link> e os capítulos das
    extensões para maiores informações de como compilar seu PHP.
   </para>
   <para>
    A leitura e entendimento de um protótipo de função é explicado na
    seção do manual entitulada
    <link linkend="about.prototypes">como ler uma definição de função</link>.
    É importante perceber o que a função retorna ou se a função trabalha
    diretamente no valor passado como argumento. Por exemplo,
    <function>str_replace</function> irá retornar a string modificada enquanto
    <function>usort</function> trabalha na própria variável passada no
    argumento. Cada página do manual também contém informações específicas de cada
    função, como: parâmetros da função, mudanças de comportamento,
    valores de retorno tanto para sucesso e erros, como outras informações disponíveis.
    O conhecimento destas diferenças importantes é crucial para
    escrever corretamente seu código PHP.
   </para>
   <para>
    Veja também <function>function_exists</function>,
    <link linkend="funcref">a referência de funções</link>,
    <function>get_extension_funcs</function> e
    <function>dl</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
