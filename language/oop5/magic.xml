<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.18 Maintainer: felipe Status: ready  --><!-- CREDITS: narigone -->
 <sect1 xml:id="language.oop5.magic" xmlns="http://docbook.org/ns/docbook">
  <title>Métodos Mágicos</title>
  <para>
   Os nomes de funções
   <literal>__construct</literal>,
   <literal>__destruct</literal>
   (veja <link linkend="language.oop5.decon">Construtores e Destrutores</link>),
   <literal>__call</literal>,
   <literal>__get</literal>,
   <literal>__set</literal>,
   <literal>__isset</literal>,
   <literal>__unset</literal>
   (veja <link linkend="language.oop5.overloading">Sobrecarga</link>),
   <literal>__sleep</literal>,
   <literal>__wakeup</literal>,
   <literal>__toString</literal>,
   <literal>__set_state</literal>,
   <link linkend="language.oop5.cloning">__clone</link> e
   <link linkend="language.oop5.autoload">__autoload</link>
   são mágicos nas classes do PHP. Você
   não pode ter funções com esses nomes em nenhuma de suas
   classes a não ser que queria que a funcionalidade mágica associada
   com eles.
  </para>

  <caution>
   <simpara>
    PHP reserva todas as funções com nomes começando com __ como mágicas.
    É recomendado que você não use funções com nomes com
    __ no PHP a não ser que você queira alguma funcionalidade mágica documentada.
   </simpara>
  </caution>

  <sect2 xml:id="language.oop5.magic.sleep">
   <title><literal>__sleep</literal> and <literal>__wakeup</literal></title>
   <para>
    <function>serialize</function> checa se sua classe tem uma função com
    o nome mágico <literal>__sleep</literal>. Se tiver, a função é
    executa antes de qualquer serialização. Ela pode limpar o objeto
    e deve retornar um array com os nomes de todas as variáveis
    do objeto que devem ser serializadas. Se o método não retornar nada,
    então &null; é serializada e um E_NOTICE é disparado.
   </para>
   <para>
    O intuito do método <literal>__sleep</literal> enviar dados
    pendentes ou realizar tarefas similares de limpeza. Além disso, a função é
    útil se você tiver objetos muito grandes que não precisarão ser
    salvos completamente.
   </para>
   <para>
    Inversamente, <function>unserialize</function> checa pela
    presença da função com o nome mágico
    <literal>__wakeup</literal>. Se achar, essa função pode
    reconstruir qualquer recursos que o objeto pode ter.
   </para>
   <para>
    O intuito do método <literal>__wakeup</literal> é
    reestabelecer qualquer conexão com banco de dados que podem ter sido perdidas
    durante a serialização e realizar tarefas de
    reinicialização.
   </para>
   <example>
    <title>Sleep e wakeup</title>
     <programlisting role="php">
<![CDATA[
<?php
class Connection {
    protected $link;
    private $server, $username, $password, $db;

    public function __construct($server, $username, $password, $db)
    {
        $this->server = $server;
        $this->username = $username;
        $this->password = $password;
        $this->db = $db;
        $this->connect();
    }

    private function connect()
    {
        $this->link = mysql_connect($this->server, $this->username, $this->password);
        mysql_select_db($this->db, $this->link);
    }

    public function __sleep()
    {
        return array('server', 'username', 'password', 'db');
    }

    public function __wakeup()
    {
        $this->connect();
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.tostring">
   <title><literal>__toString</literal></title>
   <para>
    O método <literal>__toString</literal> permite que uma classe decida
    como se comportar quando for convertida para uma string.
   </para>
   <example>
    <title>Exemplo Simples</title>
    <programlisting role="php">
<![CDATA[
<?php
// Declara uma classe simples
class ClasseTeste
{
    public $foo;

    public function __construct($foo) {
        $this->foo = $foo;
    }

    public function __toString() {
        return $this->foo;
    }
}

$classe = new ClasseTeste('Olá');
echo $classe;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Olá
]]>
    </screen>
   </example>
   <para>
    Vale lembrar que antes do PHP 5.2.0 o método <literal>__toString</literal>
    só era chamado quando diretamente combinado com
    <function>echo</function> ou <function>print</function>.
    Desde o PHP 5.2.0, ele é chamado no contexto de string (e.g. em 
    <function>printf</function> com modificador <literal>%s</literal>) mas não
    em outros tipos de contextos (e.g. como modificador <literal>%d</literal>).
    Desde o PHP 5.2.0, convertendo objetos sem o método <literal>__toString()</literal>
    para string causa <constant>E_RECOVERABLE_ERROR</constant>.
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.magic.set-state">
   <title><literal>__set_state</literal></title>
   <para>
    Esse método <link linkend="language.oop5.static">estático</link> é chamado
    para classes exportadas por <function>var_export</function> desde PHP 5.1.0.
   </para>
   <para>
    O único parâmetro para esse método é um array contendo propriedades
    exportadas no formato <literal>array('property' => value, ...)</literal>.
   </para>
  </sect2>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
