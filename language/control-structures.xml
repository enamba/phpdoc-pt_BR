 <chapter id="control-structures">
  <title>Estruturas de Controle</title>

  <simpara>
   Qualquer script PHP é construído por uma série de comandos. Um comando
   pode ser uma atribuição, uma chamada de função, um 'loop', um comando
   condicional, ou mesmo um comando que não faz nada( um comando vazio).
   Comandos geralmente terminam com um ponto-e-vírgula. Além disso, os
   comandos podem ser agrupados em um grupo de comandos através do encapsulamento
   de um grupo de comandos com colchetes. Um grupo de comandos é um comando
   também. Os vários tipos de comandos são descritos neste capítulo.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    A construção <literal>if</literal> é uma das mais importantes implementações de
    muitas linguagens, incluindo o PHP. Ela permite a execução condicional de fragmentos
    de código. O PHP implementa uma  estrutura <literal>if</literal>
     que é similar àquela do C:
    <informalexample>
     <programlisting>
if (expr)
    statement
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Como descrito na seção sobre expressões, expr é avaliada por seu valor verdadeiro.
    Se <replaceable>expr</replaceable> for avaliada como
    <literal>TRUE</literal>, o PHP executará o comando, e se for avaliada como
    <literal>FALSE</literal> - o PHP o ignorará o comando.
   </simpara>
   <para>
    Os exemplos a seguir mostrariam <computeroutput>a é maior que 
    b</computeroutput> se <replaceable>$a</replaceable> for maior que
    <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
if ($a > $b)
    print "a é maior que b";
     </programlisting>
    </informalexample>
   </para>
   <para>
    Frequentemente você vai querer ter mais que um comando a ser executado condicionalmente.
    É claro, não há necessidade de englobar cada comando com uma cláusula 
    <literal>if</literal>. Em vez disso, você pode agrupar vários comandos em um grupo de 
    comandos. Por exemplo, este código mostraria <computeroutput>a é maior que b</computeroutput>
    se <replaceable>$a</replaceable> for maior que
    <replaceable>$b</replaceable>, e então atribuiria o valor de 
    <replaceable>$a</replaceable> para <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a é maior que b";
    $b = $a;
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Comandos 'if' podem ser aninhados indefinidamente dentro de outros comandos
    <literal>if</literal>, o que faz com que você complete a flexibilidade para a
    execução condicional de várias partes do seu programa.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Frequentemente você vai querer executar um comando se uma certa condição for encontrada, e 
    e um comando diferente se a condição não for encontrada.  Isto é o que 
    o <literal>else</literal> faz.  <literal>else</literal> estende um comando
    <literal>if</literal> para executar um comando caso a expressão no comando
    <literal>if</literal> seja avaliada como <literal>FALSE</literal>. Por exemplo, o código a 
    seguir mostraria <computeroutput>a é maior que b</computeroutput> se <replaceable>$a</replaceable> 
    for maior que <replaceable>$b</replaceable>, e <computeroutput>a NÃO é maior que
    b</computeroutput> caso contrário:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a é maior que b";
} else {
    print "a NÃO é maior que b";
}
     </programlisting>
    </informalexample>

    O comando <literal>else</literal> só é executado se a expressão
    <literal>if</literal> for avaliada como
    <literal>FALSE</literal>, e se houver qualquer expressão
    <literal>elseif</literal> - somente se eles forem avaliadas como
    <literal>FALSE</literal> também (veja <link
    linkend="control-structures.elseif">elseif</link>).

   </para>
  </sect1>
 
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, como seu nome sugere, é uma combinação
    de <literal>if</literal> e <literal>else</literal>. Da mesma forma que o
    <literal>else</literal>, ele estende um comando <literal>if</literal>
    para executar um comando diferente no caso de a expressão
    <literal>if</literal> original ser avaliada como
    <literal>FALSE</literal>. Porém, ao contrário de 
    <literal>else</literal>, ele executará aquela expressão alternativa 
    somente se a expressão condicional do <literal>elseif</literal> for 
    avaliada como <literal>TRUE</literal>. Por exemplo, o código a seguir
    mostraria <computeroutput>a é maior que 
    b</computeroutput>, <computeroutput>a é igual a b</computeroutput>
    ou <computeroutput>a é menor que b</computeroutput>:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a é maior que b";
} elseif ($a == $b) {
    print "a é igual a b";
} else {
    print "a é menor que b";
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Podem haver vários <literal>elseif</literal>s dentro do mesmo comando
    <literal>if</literal>. A primeira expressão
    <literal>elseif</literal> (se houver) que for avaliada como
    <literal>true</literal> será executada. Em PHP, você também pode escrever
    'else if' (em duas palavras) e o comportamento será indêntico a um
    'elseif' (em uma só palavra). O significado sintático é ligeiramente diferente
    (se você está familiarizado com C, isto tem o mesmo comportamento),
    mas o resultado é que ambos resultariam exatamente no mesmo comportamento.
   </simpara>
   <simpara>
    O comando <literal>elseif</literal> só é executado se a expressão
    <literal>if</literal> precedente e quaisquer expressões
    <literal>elseif</literal> precedentes forem avaliadas como
    <literal>FALSE</literal>, e a expressão
    <literal>elseif</literal> corrente for avaliada como
    <literal>TRUE</literal>.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.alternative-syntax">
   <title>Sintaxe alternativa para estruturas de controle</title>
   <para>
    O PHP oferece uma sintaxe alternativa para algumas das suas estruturas
    de controle; nominalmente, <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>, e
    <literal>switch</literal>. Em cada caso, a forma básica da sintaxe alternativa é mudar
    o sinal de abertura para dois-pontos (:) e o sinal de fechamento para <literal>endif;</literal>,
    <literal>endwhile;</literal>, <literal>endfor;</literal>, ou
    <literal>endswitch;</literal>, respectivamente.
    <informalexample>
     <programlisting role="php">
 &lt;?php if ($a == 5): ?&gt;
 A é igual a 5
 &lt;?php endif; ?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    No exemplo acima, o bloco HTML "A = 5" está aninhado dentro de um comando
    <literal>if</literal> escrito na sintaxe alternativa.
    O bloco HTML seria mostrado somente se $a é igual a 5.
   </simpara>
   <para>
    A sintaxe alternativa se aplica a <literal>else</literal> e
    <literal>elseif</literal> também.  A seguir vem uma estrutura
    <literal>if</literal> com <literal>elseif</literal> e
    <literal>else</literal> no formato alternativo:
    <informalexample>
     <programlisting role="php">
if ($a == 5):
    print "a é igual a 5";
    print "...";
elseif ($a == 6):
    print "a é igual a 6";
    print "!!!";
else:
    print "a não é 5 nem 6";
endif;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Veja também <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, e <link
    linkend="control-structures.if">if</link> para mais exemplos.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    Loops <literal>while</literal> são o tipo mais simples de criar um 'loop' em
    PHP. Eles se comportam como seus compatíveis em C. O formato básico de um comando
    <literal>while</literal> é:
    <informalexample>
     <programlisting>
while (expr) statement
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    O significado de um comando <literal>while</literal> é simples. Ele pede que o PHP
    execute os comandos aninhados repetidamente, enquanto a expressão 
    <literal>while</literal> é avaliada como
    <literal>TRUE</literal>. O valor da expressão é verificada cada vez que se passa
    no começo do 'loop', desta forma mesmo que este valor mude durante a execução do(s)
    comando(s) aninhado(s), a execução não parará até que o fim da iteração (cada vez que o
    PHP roda os comandos dentro do 'loop' é uma iteração). Às vezes, se a expressão
    <literal>while</literal> é avaliada como <literal>FALSE</literal> logo no início,
    o(s) comando(s) aninhado(s) não será(ão) rodado(s) nem uma vez sequer.
   </simpara>
   <para>
    Como no comando <literal>if</literal>, você pode agrupar múltiplos comandos dentro 
    do mesmo 'loop' <literal>while</literal> englobando um grupo de comandos com
    colchetes, ou usando a sintaxe alternativa:
    <informalexample>
     <programlisting>
while (expr): statement ... endwhile;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Os exemplos a seguir são idênticos, e ambos imprimem números de 1 to 10:
    <informalexample>
     <programlisting>
/* exemplo 1 */

$i = 1;
while ($i &lt;= 10) {
    print $i++;  /* o valor impresso será 
                    $i antes do incremento
                    (pós-incremento) */
}
 
/* exemplo 2 */
 
$i = 1;
while ($i &lt;= 10):
    print $i;
    $i++;
endwhile;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    Loops <literal>do..while</literal> são bem similares aos 'loops'
    <literal>while</literal>, exceto pelo fato de que expressões-verdade
    são verificadas no fim de cada iteração em vez de no começo.
    A diferença principal dos 'loops' <literal>while</literal> regulares é que 
    a primeira iteração de um 'loop' <literal>do..while</literal> é garantidamente 
    rodada (a expressão-verdade só é verificada no fim da iteração), enquanto que 
    ele pode não rodar necessariamente em um 'loop' 
    <literal>while</literal> regular (a expressão-verdade é verificada no começo de 
    cada iteração, se ela é avaliada como
    <literal>FALSE</literal> logo no começo, a execução do 'loop' terminaria
    imediatamente).
   </simpara>
   <para>
    Há apenas uma sintaxe para 'loops' <literal>do..while</literal>:
 
    <informalexample>
     <programlisting role="php">
$i = 0;
do {
   print $i;
} while ($i>0);
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     O 'loop' acima rodaria exatamente uma vez, desde que depois da primeira
     iteração, quando a expressão-verdade é verificada, ela é avaliada como
     <literal>FALSE</literal> ($i não é maior que zero 0) e a execução do 'loop'
     termina.
   </simpara>
   <para>
    Usuários avançados de C podem estar familiarizados com o uso diferenciado do
    'loop' <literal>do..while</literal>, para permitir o fim da execução no
    meio dos blocos de código, englobando-os com
    <literal>do..while</literal>(0), e usando o comando <link
    linkend="control-structures.break"><literal>break</literal></link>
    statement. O fragmento de código a seguir demonstra isso:
    <informalexample>
     <programlisting role="php">
do {
    if ($i &lt; 5) {
        print "i não é grande o suficiente";
        break;
    }
    $i *= $factor;
    if ($i &lt; $minimum_limit) {
        break;
    }
    print "i está correto";

     ...process i...

} while(0);
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Não se preocupe se você não entendeu isto da forma certa ou de jeito nenhum.
    Você pode codificar scripts e mesmo poderosos scripts sem usar essa
    `opção'.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    Loops <literal>for</literal> são os 'loops' mais complexos em PHP.
    Eles se comportam como os seus compatíveis em C. A sintaxe de um 'loop'
    <literal>for</literal> é:
    <informalexample>
     <programlisting>
for (expr1; expr2; expr3) statement
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    A primeira expressão (<replaceable>expr1</replaceable>) é
    avaliada (executada) uma vez incondicionalmente no começo do 'loop'.
   </simpara>
   <simpara>
    No começo de cada iteração, <replaceable>expr2</replaceable> é avaliada. 
    Se ela é avaliada como <literal>TRUE</literal>, o 'loop' continua e o(s)
    comando(s) aninhado(s) é(são) executado(s). Se é avaliada como
    <literal>FALSE</literal>, a execução do 'loop' termina.
   </simpara>
   <simpara>
    No fim de cada iteração, <replaceable>expr3</replaceable> é avaliada
    (executada).
   </simpara>
   <simpara>
    Cada uma das expressões pode ser vazia.
    <replaceable>expr2</replaceable> vazia significa que o 'loop' pode rodar
    indefinidamente (PHP considera-a implicitamente como
    <literal>TRUE</literal>, como em C). Isto pode não ser tão inútil quanto 
    você pode pensar, pois frequentemente você pode querer terminar o 'loop'
    usando um comando <link
    linkend="control-structures.break"><literal>break</literal></link>
    condicional em vez de usar a expressão-verdade do <literal>for</literal>.
   </simpara>
   <para>
    Considere os seguintes exemplos. Todos eles mostram números de 1 a 10:
    <informalexample>
     <programlisting role="php">
/* exemplo 1 */
 
for ($i = 1; $i &lt;= 10; $i++) {
    print $i;
}
 
/* exemplo 2 */
 
for ($i = 1;;$i++) {
    if ($i &gt; 10) {
        break;
    }
    print $i;
}
 
/* exemplo 3 */
 
$i = 1;
for (;;) {
    if ($i &gt; 10) {
        break;
    }
    print $i;
    $i++;
}
 
/* exemplo 4 */
 
for ($i = 1; $i &lt;= 10; print $i, $i++) ;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Obviamente, o primeiro exemplo parece ser o mais bonito (ou talvez o quarto), mas
    você pode perceber que a possível utilização de expressões vazias em 'loops'
    <literal>for</literal> se torna prático em muitas ocasiões.
   </simpara>
   <para>
    O PHP também suporta a "sintaxe de dois-pontos" alternativa para 'loops'
    <literal>for</literal>.
    <informalexample>
     <programlisting>
for (expr1; expr2; expr3): statement; ...; endfor;
     </programlisting>
     </informalexample>
   </para>
   <para>
    Outras linguagens têm um comando <literal>foreach</literal> para varrer uma 
    matriz ou tabela de hashing. O PHP3 não tem uma construção deste tipo; O PHP4 tem
    (veja <link linkend="control-structures.foreach">foreach</link>). Em PHP3, 
    você pode combinar <link linkend="control-structures.while">while</link>
    com as funções <function>list</function> e <function>each</function> para
    obter o mesmo efeito. Veja a documentação para estas funções para ter um
    exemplo.
   </para>

  </sect1>
  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    O PHP4 (não o PHP3) inclui uma construção <literal>foreach</literal>,
    muito parecido com o perl e outras linguagens. Isto simplesmente oferece uma  
    maneira fácil de iterar sobre matrizes. Há duas sintaxes; a segunda é uma 
    extensão menor, mas útil, da primeira:
    <informalexample>
     <programlisting>
foreach(array_expression as $value) statement
foreach(array_expression as $key => $value) statement
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    A primeira forma varre uma dada matriz dada por
    <literal>array_expression</literal>. Em cada 'loop', o valor do elemento
    corrente é atribuído a <literal>$value</literal> e o ponteiro interno da
    matriz é avançado em uma posição (assim, no próximo 'loop' você estará
    olhando para o próximo elemento).
   </simpara>
   <simpara>
    A segunda forma faz a mesma coisa, exceto pelo fato de que a chave do elemento
    corrente será atribuído à variável <literal>$key</literal> em cada 'loop'.
   </simpara>
   <para>
    <note>
     <para>
	  Quando o <literal>foreach</literal> inicia sua primeira execução, o ponteiro
      interno da matriz é zerado automaticamente para o primeiro elemento da matriz.
      Isto significa que você não precisa chamar
      <function>reset</function> antes de um 'loop' <literal>foreach</literal>.
	 </para>
	</note>
   </para>
   <para>
    <note>
	 <para>
	   Note também que <literal>foreach</literal> opera sobre uma cópia da matriz
	   especificada, não na própria matriz, portanto o ponteiro da matriz não é 
	   modificado como na construção 'each'.
	 </para>
    </note>
   </para>
   <para>
    Você pode ter notado que os seguintes itens são funcionalmente idênticos:
    <informalexample>
     <programlisting role="php">
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Value: $value&lt;br&gt;\n";
}

foreach ($arr as $value) {
    echo "Value: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
    Os seguintes tanbém são funcionalmente idênticos:
    <informalexample>
     <programlisting role="php">
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Key: $key; Value: $value&lt;br&gt;\n";
}

foreach ($arr as $key => $value) {
    echo "Key: $key; Value: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Mais alguns exemplos para demonstrar os usos:
    <informalexample>
     <programlisting role="php">
/* exemplo de foreach 1: só valor */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
   print "Valor corrente de \$a: $v.\n";
}

/* exemplo de foreach 2: valor (com a chave impressa para ilustração) */

$a = array (1, 2, 3, 17);

$i = 0; /* só para propósito de ilustração */

foreach($a as $v) {
    print "\$a[$i] => $k.\n";
}

/* exemplo de foreach 3: chave e valor */

$a = array (
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "seventeen" => 17
);

foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   
   <simpara>
    <literal>break</literal> termina a execução da estrutura
    <literal>for</literal>, <literal>while</literal>, ou
    <literal>switch</literal> corrente.
   </simpara>

   <simpara>
    <literal>break</literal> aceita um argumento numérico opcional que diz a ele
    quantas estruturas aninhadas englobadas devem ser quebradas.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
$arr = array( 'one', 'two', 'three', 'four', 'stop', 'five' );
while ( list( , $val ) = each( $arr ) ) {
   if ( $val == 'stop' ) {
      break;    /* Você também poderia escrever 'break 1;' aqui. */
   }
   echo "$val&lt;br&gt;\n";
}

/* Usando o argumento opcional. */
$i = 0;
while ( ++$i ) {
    switch ( $i ) {
    case 5:
        echo "At 5&lt;br&gt;\n";
        break 1;  /* sai somento de 'switch'. */
    case 10:
        echo "At 10; quitting&lt;br&gt;\n";
        break 2;  /* sai de 'switch' e de 'while'. */
    default:
        break;
    }
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> é usado dentro de estruturas de 'loops'
    para saltar o resto da iteração do 'loop' corrente e continuar a execução
    no início da próxima iteração.
   </simpara>
   <simpara>
    <literal>continue</literal> aceita um argumento numérico opcional que diz
    a ele de quantos níveis de 'loops' englobados ele deveria saltar até o fim. 
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
while (list ($key, $value) = each ($arr)) {
   if (!($key % 2)) { // salta membros ímpares
       continue;
   }
   do_something_odd ($value);
}

$i = 0;
while ($i++ &lt; 5) {
    echo "Mais externo&lt;br&gt;\n";
    while (1) {
        echo "&nbsp;&nbsp;Meio&lt;br&gt;\n";
        