<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.14 Maintainer: felipe Status: ready --><!-- CREDITS: kappu -->
 <reference xml:id="ref.regex" xmlns="http://docbook.org/ns/docbook">
  <title>Regex: Expressões Regulares (compatíveis com o padrão POSIX)</title>
  <titleabbrev>Regexps</titleabbrev>

  <partintro>
   <section xml:id="regex.intro">
    &reftitle.intro;
    <tip>
     <para>
      PHP também suporta expressões regulares compatíveis com a sintaxe do Perl
      usando as <link linkend="ref.pcre">Funções PCRE</link>. Essas funções
      suportam non-greedy matching, assertions, conditional subpatterns, e várias
      outras características que não são suportadas pelas Expressões Regulares
      compatíveis com o padrão POSIX.
     </para>
    </tip>
    <warning>
     <para>
      Estas expressões regulares não são seguras para dados binários. As
      <link linkend="ref.pcre">Funções PCRE</link> são.
     </para>
    </warning>
    <para>
     Expressões regulares são usadas para manipulação de strings complexas.
     PHP usa expressões regulares POSIX extended como definido pela POSIX
     1003.2. Para uma completa descrição das expressões regulares POSIX veja a 
     <link xlink:href="&url.regex.man;">regex man pages</link> incluida no diretório regex
     na sua distribuição do PHP. Ele está no formato
     de manpage, então você precisa de 
     <command>man /usr/local/src/regex/regex.7</command> para lê-lo.
    </para>
   </section>

   <section xml:id="regex.requirements">
    &reftitle.required;
    &no.requirement;
   </section>

   &reference.regex.configure;

   <section xml:id="regex.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section xml:id="regex.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   <section xml:id="regex.constants">
    &reftitle.constants;
    &no.constants;
   </section>

   <section xml:id="regex.examples">
    &reftitle.examples;
    <para>
     <example>
     <title>Exemplos de Expressões Regulares</title>
      <programlisting role="php">
<![CDATA[
<?php
// Retorna true se "abc" existir em qualquer lugar de $string.
ereg ("abc", $string);

// Retorna true se "abc" existir no início de $string.
ereg ("^abc", $string);

// Retorna true se "abc" existir no final de $string.
ereg ("abc$", $string);

// Retorna true se o navegador do cliente  for Netscape 2, 3 ou MSIE 3.
eregi ("(ozilla.[23]|MSIE.3)", $_SERVER["HTTP_USER_AGENT"]);

// Adiciona três palavras separadas por espaço em $regs[1], $regs[2] e $regs[3].
ereg ("([[:alnum:]]+) ([[:alnum:]]+) ([[:alnum:]]+)", $string,$regs);

// Acrescenta a tag <br /> no início de $string.
$string = ereg_replace ("^", "<br />", $string);

// Acrescenta a tag <br />; no final de $string.
$string = ereg_replace ("$", "<br />", $string);

// Remove todos caracteres de nova linha (newline) em $string.
$string = ereg_replace ("\n", "", $string);
?>
]]>
      </programlisting>
     </example>
    </para>
   </section>

   <section xml:id="regex.seealso">
    &reftitle.seealso;
    <para>
     Para expressões regulares compatíveis com o padrão Perl veja
     <link linkend="ref.pcre">PCRE, Funções</link>. O estilo simples de wildcard
     do shell pode ser usado com a função <function>fnmatch</function>.
    </para>
   </section>
  </partintro>

  &reference.regex.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

